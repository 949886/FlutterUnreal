diff --git a/BUILD.gn b/BUILD.gn
index 68af9e4984..cb91f9f989 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -5,6 +5,9 @@
 
 import("gn/fuchsia_defines.gni")
 import("gn/shared_sources.gni")
+if (is_win) {
+  import("gn/gpu_d3d11.gni")
+}
 import("gn/skia.gni")
 import("gn/toolchain/wasm.gni")
 
@@ -1033,8 +1036,10 @@ optional("gpu") {
 
   if (skia_use_direct3d) {
     public_defines += [ "SK_DIRECT3D" ]
+    public += skia_d3d11_public
     deps += [ "//third_party/d3d12allocator" ]
     sources += skia_direct3d_sources
+    sources += skia_d3d11_sources
     if (skia_enable_direct3d_debug_layer) {
       public_defines += [ "SK_ENABLE_D3D_DEBUG_LAYER" ]
     }
@@ -1042,9 +1047,11 @@ optional("gpu") {
       "d3d12.lib",
       "dxgi.lib",
       "d3dcompiler.lib",
+      "d3d11.lib",
+      "dxguid.lib",
     ]
   }
-
+  
   cflags_objcc = []
   if (skia_use_metal) {
     public_defines += [ "SK_METAL" ]
diff --git a/gn/gpu_d3d11.gni b/gn/gpu_d3d11.gni
new file mode 100644
index 0000000000..ea3608e23d
--- /dev/null
+++ b/gn/gpu_d3d11.gni
@@ -0,0 +1,39 @@
+
+_src = get_path_info("../src", "abspath")
+_include = get_path_info("../include", "abspath")
+
+skia_d3d11_public = [
+  "$_include/gpu/ganesh/d3d11/GrD3D11Types.h",
+  "$_include/gpu/ganesh/d3d/GrD3DBackendContext.h"
+]
+
+skia_d3d11_sources = [
+  "$_include/gpu/d3d11/GrD3D11Types.h",
+  "$_include/private/gpu/ganesh/GrD3D11TypesPriv.h",
+  "$_src/gpu/ganesh/d3d11/GrD3D11Attachment.h",
+  "$_src/gpu/ganesh/d3d11/GrD3D11Attachment.cpp",
+  "$_src/gpu/ganesh/d3d11/GrD3D11Buffer.h",
+  "$_src/gpu/ganesh/d3d11/GrD3D11Buffer.cpp",
+  "$_src/gpu/ganesh/d3d11/GrD3D11Caps.cpp",
+  "$_src/gpu/ganesh/d3d11/GrD3D11Caps.h",
+  "$_src/gpu/ganesh/d3d11/GrD3D11Gpu.cpp",
+  "$_src/gpu/ganesh/d3d11/GrD3D11Gpu.h",
+  "$_src/gpu/ganesh/d3d11/GrD3D11OpsRenderPass.h",
+  "$_src/gpu/ganesh/d3d11/GrD3D11OpsRenderPass.cpp",
+  "$_src/gpu/ganesh/d3d11/GrD3D11OpTarget.h",
+  "$_src/gpu/ganesh/d3d11/GrD3D11RenderTask.h",
+  "$_src/gpu/ganesh/d3d11/GrD3D11SurfaceProxy.h",
+  "$_src/gpu/ganesh/d3d11/GrD3D11Texture.h",
+  "$_src/gpu/ganesh/d3d11/GrD3D11Texture.cpp",
+  "$_src/gpu/ganesh/d3d11/GrD3D11RenderTarget.h",
+  "$_src/gpu/ganesh/d3d11/GrD3D11RenderTarget.cpp",
+  "$_src/gpu/ganesh/d3d11/GrD3D11TextureRenderTarget.h",
+  "$_src/gpu/ganesh/d3d11/GrD3D11TextureRenderTarget.cpp",
+  "$_src/gpu/ganesh/d3d11/GrD3D11Types.cpp",
+  "$_src/gpu/ganesh/d3d11/GrD3D11ProgramBuilder.h",
+  "$_src/gpu/ganesh/d3d11/GrD3D11ProgramBuilder.cpp",
+  "$_src/gpu/ganesh/d3d11/GrD3D11ResourceProvider.cpp",
+  "$_src/gpu/ganesh/d3d11/GrD3D11ResourceProvider.h",
+  "$_src/gpu/ganesh/d3d11/GrD3D11UniformDataManager.cpp",
+  "$_src/gpu/ganesh/d3d11/GrD3D11UniformDataManager.h",
+]
diff --git a/gn/skia.gni b/gn/skia.gni
index 0912d15e49..d64bd745dc 100644
--- a/gn/skia.gni
+++ b/gn/skia.gni
@@ -40,7 +40,7 @@ declare_args() {
   skia_use_angle = false
   skia_use_client_icu = false
   skia_use_dawn = false
-  skia_use_direct3d = false
+  skia_use_direct3d = is_win
   skia_use_egl = false
   skia_use_epoxy_egl = false
   skia_use_expat = !is_wasm
@@ -126,7 +126,7 @@ declare_args() {
   if (is_fuchsia) {
     skia_use_vulkan = true
   } else {
-    skia_use_vulkan = false
+    skia_use_vulkan = is_win || is_android
   }
 
   skia_build_fuzzers = is_clang && is_linux && target_cpu == "x64"
diff --git a/include/gpu/ganesh/GrBackendSurface.h b/include/gpu/ganesh/GrBackendSurface.h
index cb7239ad5e..19998a1553 100644
--- a/include/gpu/ganesh/GrBackendSurface.h
+++ b/include/gpu/ganesh/GrBackendSurface.h
@@ -252,6 +252,7 @@ private:
 #ifdef SK_DIRECT3D
     friend class GrD3DTexture;
     friend class GrD3DGpu;     // for getGrD3DResourceState
+    friend class GrD3D11Texture;
     GrBackendTexture(int width,
                      int height,
                      const GrD3DTextureResourceInfo& vkInfo,
@@ -380,6 +381,7 @@ private:
 #ifdef SK_DIRECT3D
     friend class GrD3DGpu;
     friend class GrD3DRenderTarget;
+    friend class GrD3D11RenderTarget;
     GrBackendRenderTarget(int width,
                           int height,
                           const GrD3DTextureResourceInfo& d3dInfo,
diff --git a/include/gpu/ganesh/d3d/GrD3DBackendContext.h b/include/gpu/ganesh/d3d/GrD3DBackendContext.h
index 730ba42304..42550ce558 100644
--- a/include/gpu/ganesh/d3d/GrD3DBackendContext.h
+++ b/include/gpu/ganesh/d3d/GrD3DBackendContext.h
@@ -30,6 +30,8 @@ struct SK_API GrD3DBackendContext {
     gr_cp<ID3D12CommandQueue> fQueue;
     sk_sp<GrD3DMemoryAllocator> fMemoryAllocator;
     GrProtected fProtectedContext = GrProtected::kNo;
+    void* fD3D11Device = nullptr;
+    void* fD3D11DeviceContext = nullptr;
 };
 
 #endif
diff --git a/include/gpu/ganesh/d3d11/BUILD.bazel b/include/gpu/ganesh/d3d11/BUILD.bazel
new file mode 100644
index 0000000000..a3d82ae673
--- /dev/null
+++ b/include/gpu/ganesh/d3d11/BUILD.bazel
@@ -0,0 +1,12 @@
+load("//bazel:macros.bzl", "exports_files_legacy", "skia_filegroup")
+
+licenses(["notice"])
+
+exports_files_legacy()
+
+skia_filegroup(
+    name = "public_hdrs",
+    srcs = [
+        "GrD3D11Types.h",
+    ],
+)
diff --git a/include/gpu/ganesh/d3d11/GrD3D11Types.h b/include/gpu/ganesh/d3d11/GrD3D11Types.h
new file mode 100644
index 0000000000..6311d24361
--- /dev/null
+++ b/include/gpu/ganesh/d3d11/GrD3D11Types.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef GrD3D11Types_DEFINED
+#define GrD3D11Types_DEFINED
+
+#include "include/gpu/ganesh/GrTypes.h"
+#include "include/private/gpu/ganesh/GrTypesPriv.h"
+#include "include/gpu/ganesh/d3d/GrD3DTypes.h"
+
+#include <d3d11.h>
+
+class GrBackendFormat;
+class GrBackendTexture;
+class GrBackendRenderTarget;
+
+struct GrD3D11TextureInfo {
+    GrD3D11TextureInfo() = default;
+    explicit GrD3D11TextureInfo(const GrD3DTextureResourceInfo& info) {
+        fLevelCount = info.fLevelCount;
+        fSampleCount = info.fSampleCount;
+        fProtected = info.fProtected;
+        fFormat = info.fFormat;
+        fTexture.retain((ID3D11Texture2D*)info.fResource.get());
+    }
+
+    GrD3DTextureResourceInfo toD3D12Info() const {
+        GrD3DTextureResourceInfo d3d12Info;
+        d3d12Info.fLevelCount = fLevelCount;
+        d3d12Info.fSampleCount = fSampleCount;
+        d3d12Info.fProtected = fProtected;
+        d3d12Info.fFormat = fFormat;
+        d3d12Info.fResource.retain((ID3D12Resource*)fTexture.get());
+        return d3d12Info;
+    }
+
+    static GrD3D11TextureInfo getInfo(const GrBackendTexture& backend);
+    static GrD3D11TextureInfo getInfo(const GrBackendRenderTarget& backend);
+
+    GrBackendFormat getBackendFormat() const;
+
+    uint32_t fLevelCount = 1;
+    uint32_t fSampleCount = 1;
+    GrProtected fProtected = GrProtected::kNo;
+    DXGI_FORMAT fFormat = DXGI_FORMAT::DXGI_FORMAT_UNKNOWN;
+    gr_cp<ID3D11Texture2D> fTexture;
+};
+
+struct GrD3D11SurfaceInfo {
+    uint32_t fSampleCount = 1;
+    uint32_t fLevelCount = 0;
+    GrProtected fProtected = GrProtected::kNo;
+
+    DXGI_FORMAT fFormat = DXGI_FORMAT_UNKNOWN;
+    unsigned int fSampleQualityPattern = DXGI_STANDARD_MULTISAMPLE_QUALITY_PATTERN;
+};
+
+#endif
diff --git a/include/private/gpu/ganesh/GrD3D11TypesPriv.h b/include/private/gpu/ganesh/GrD3D11TypesPriv.h
new file mode 100644
index 0000000000..c35bc0fb51
--- /dev/null
+++ b/include/private/gpu/ganesh/GrD3D11TypesPriv.h
@@ -0,0 +1,14 @@
+/*
+ * Copyright 2021 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef GrD3D11TypesPriv_DEFINED
+#define GrD3D11TypesPriv_DEFINED
+
+#include "include/gpu/ganesh/d3d11/GrD3D11Types.h"
+
+#endif
+
diff --git a/src/gpu/ganesh/GrProgramDesc.h b/src/gpu/ganesh/GrProgramDesc.h
index 6f7ec80d96..b70383d51d 100644
--- a/src/gpu/ganesh/GrProgramDesc.h
+++ b/src/gpu/ganesh/GrProgramDesc.h
@@ -58,6 +58,7 @@ public:
 protected:
     friend class GrDawnCaps;
     friend class GrD3DCaps;
+    friend class GrD3D11Caps;
     friend class GrGLCaps;
     friend class GrMockCaps;
     friend class GrMtlCaps;
diff --git a/src/gpu/ganesh/GrSPIRVUniformHandler.h b/src/gpu/ganesh/GrSPIRVUniformHandler.h
index 236471002c..2b5077deb6 100644
--- a/src/gpu/ganesh/GrSPIRVUniformHandler.h
+++ b/src/gpu/ganesh/GrSPIRVUniformHandler.h
@@ -80,6 +80,7 @@ private:
     uint32_t fRTFlipOffset = 0;
 
     friend class GrD3DPipelineStateBuilder;
+    friend class GrD3D11ProgramBuilder;
     friend class GrDawnProgramBuilder;
 
     using INHERITED = GrGLSLUniformHandler;
diff --git a/src/gpu/ganesh/d3d/GrD3DGpu.cpp b/src/gpu/ganesh/d3d/GrD3DGpu.cpp
index 54c44c0c75..cd55ade2f3 100644
--- a/src/gpu/ganesh/d3d/GrD3DGpu.cpp
+++ b/src/gpu/ganesh/d3d/GrD3DGpu.cpp
@@ -6,6 +6,7 @@
  */
 
 #include "src/gpu/ganesh/d3d/GrD3DGpu.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Gpu.h"
 
 #include "include/core/SkColorSpace.h"
 #include "include/core/SkTextureCompressionType.h"
@@ -50,6 +51,10 @@ sk_sp<GrThreadSafePipelineBuilder> GrD3DGpu::refPipelineBuilder() {
 std::unique_ptr<GrGpu> GrD3DGpu::Make(const GrD3DBackendContext& backendContext,
                                       const GrContextOptions& contextOptions,
                                       GrDirectContext* direct) {
+    if (backendContext.fD3D11Device) {
+        return GrD3D11Gpu::Make(direct, contextOptions, backendContext);
+    }
+
     sk_sp<GrD3DMemoryAllocator> memoryAllocator = backendContext.fMemoryAllocator;
     if (!memoryAllocator) {
         // We were not given a memory allocator at creation
diff --git a/src/gpu/ganesh/d3d11/BUILD.bazel b/src/gpu/ganesh/d3d11/BUILD.bazel
new file mode 100644
index 0000000000..d129571b4a
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/BUILD.bazel
@@ -0,0 +1,38 @@
+load("//bazel:macros.bzl", "exports_files_legacy", "split_srcs_and_hdrs")
+
+licenses(["notice"])
+
+exports_files_legacy()
+
+D3D11_FILES = [
+    "GrD3D11Attachment.h",
+    "GrD3D11Attachment.cpp",
+    "GrD3D11Buffer.h",
+    "GrD3D11Buffer.cpp",
+    "GrD3D11Caps.cpp",
+    "GrD3D11Caps.h",
+    "GrD3D11Gpu.cpp",
+    "GrD3D11Gpu.h",
+    "GrD3D11OpsRenderPass.h",
+    "GrD3D11OpsRenderPass.cpp",
+    "GrD3D11RenderTask.h",
+    "GrD3D11SurfaceProxy.h",
+    "GrD3D11Texture.h",
+    "GrD3D11Texture.cpp",
+    "GrD3D11RenderTarget.h",
+    "GrD3D11RenderTarget.cpp",
+    "GrD3D11TextureRenderTarget.h",
+    "GrD3D11TextureRenderTarget.cpp",
+    "GrD3D11Types.cpp",
+    "GrD3D11ProgramBuilder.cpp",
+    "GrD3D11ProgramBuilder.h",
+    "GrD3D11ResourceProvider.cpp",
+    "GrD3D11ResourceProvider.h",
+    "GrD3D11UniformDataManager.cpp",
+    "GrD3D11UniformDataManager.h",
+]
+
+split_srcs_and_hdrs(
+    name = "d3d11",
+    files = D3D11_FILES,
+)
diff --git a/src/gpu/ganesh/d3d11/GrD3D11Attachment.cpp b/src/gpu/ganesh/d3d11/GrD3D11Attachment.cpp
new file mode 100644
index 0000000000..7626fe8d1e
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11Attachment.cpp
@@ -0,0 +1,105 @@
+
+#include "src/gpu/ganesh/d3d11/GrD3D11Gpu.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Attachment.h"
+
+GrD3D11Attachment::GrD3D11Attachment(GrD3D11Gpu* gpu,
+                                 SkISize dimensions,
+                                 UsageFlags supportedUsages,
+                                 DXGI_FORMAT format,
+                                 const D3D11_TEXTURE2D_DESC& desc,
+                                 const GrD3D11TextureInfo& info,
+                                 ID3D11View* view,
+                                 std::string_view label)
+        : GrAttachment(gpu,
+                       dimensions,
+                       supportedUsages,
+                       desc.SampleDesc.Count,
+                       skgpu::Mipmapped::kNo,
+                       GrProtected::kNo,
+                       label)
+        , fFormat(format)
+        , fView(view)
+        , fInfo(info) {
+    this->registerWithCache(skgpu::Budgeted::kYes);
+}
+
+sk_sp<GrD3D11Attachment> GrD3D11Attachment::MakeStencil(GrD3D11Gpu* gpu,
+                                                    SkISize dimensions,
+                                                    int sampleCnt,
+                                                    DXGI_FORMAT format) {
+    HRESULT hr;
+
+    D3D11_USAGE usage = D3D11_USAGE_DEFAULT;
+    UINT bindFlags = 0;
+    UINT cpuFlags = 0;
+    UINT miscFlags = 0;
+
+    bindFlags |= D3D11_BIND_DEPTH_STENCIL;
+
+    D3D11_TEXTURE2D_DESC desc = {};
+    desc.Width = dimensions.fWidth;
+    desc.Height = dimensions.fHeight;
+    desc.MipLevels = 1;
+    desc.Format = format;
+    desc.SampleDesc.Count = 1;
+    desc.SampleDesc.Quality = 0;
+    desc.Usage = usage;
+    desc.BindFlags = bindFlags;
+    desc.CPUAccessFlags = cpuFlags;
+    desc.MiscFlags = miscFlags;
+    desc.ArraySize = 1;
+
+    GrD3D11TextureInfo info;
+    info.fFormat = format;
+    info.fLevelCount = 1;
+    hr = gpu->device()->CreateTexture2D(&desc, nullptr, &info.fTexture);
+    GR_D3D_CALL_ERRCHECK(hr);
+
+    ID3D11DepthStencilView* depthStencilView = nullptr;
+    {
+        D3D11_DEPTH_STENCIL_VIEW_DESC viewDesc;
+        viewDesc.Format = format;
+        viewDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;
+        viewDesc.Texture2D.MipSlice = 0;
+        viewDesc.Flags = 0;
+        hr = gpu->device()->CreateDepthStencilView(info.fTexture.get(), &viewDesc, &depthStencilView);
+        GR_D3D_CALL_ERRCHECK(hr);
+    }
+
+    return sk_sp<GrD3D11Attachment>(new GrD3D11Attachment(gpu,
+                                                      dimensions,
+                                                      UsageFlags::kStencilAttachment,
+                                                      format,
+                                                      desc,
+                                                      info,
+                                                      depthStencilView,
+                                                      /*label=*/"D3DAttachment_MakeStencil"));
+}
+
+void GrD3D11Attachment::onRelease() {
+    fInfo.fTexture.reset();
+    fView.reset();
+
+    GrAttachment::onRelease();
+}
+
+void GrD3D11Attachment::onAbandon() {
+    fInfo.fTexture.reset();
+    fView.reset();
+
+    GrAttachment::onAbandon();
+}
+
+GrD3D11Gpu* GrD3D11Attachment::getD3D11Gpu() const {
+    SkASSERT(!this->wasDestroyed());
+    return static_cast<GrD3D11Gpu*>(this->getGpu());
+}
+
+void GrD3D11Attachment::onSetLabel() {
+    SkASSERT(this->d3d11Resource());
+    if (!this->getLabel().empty()) {
+        const std::string label = "_Skia_" + this->getLabel();
+        this->d3d11Resource()->SetPrivateData(
+                WKPDID_D3DDebugObjectName, label.size(), label.c_str());
+    }
+}
diff --git a/src/gpu/ganesh/d3d11/GrD3D11Attachment.h b/src/gpu/ganesh/d3d11/GrD3D11Attachment.h
new file mode 100644
index 0000000000..742bb38e49
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11Attachment.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef GrD3D11Attachment_DEFINED
+#define GrD3D11Attachment_DEFINED
+
+#include "src/gpu/ganesh/GrAttachment.h"
+#include "src/gpu/ganesh/GrBackendUtils.h"
+
+class GrD3D11Gpu;
+class GrD3D11Attachment : public GrAttachment {
+public:
+    static sk_sp<GrD3D11Attachment> MakeStencil(GrD3D11Gpu* gpu,
+                                              SkISize dimensions,
+                                              int sampleCnt,
+                                              DXGI_FORMAT format);
+
+    ~GrD3D11Attachment() override {}
+
+    GrBackendFormat backendFormat() const override { return GrBackendFormat::MakeDxgi(fFormat); }
+
+    const ID3D11View* view() const { return fView.get(); }
+
+    DXGI_FORMAT dxgiFormat() const { return fInfo.fFormat; }
+
+    ID3D11Texture2D* d3d11Resource() const { return fInfo.fTexture.get(); }
+
+    const GrD3D11TextureInfo& getInfo() const { return fInfo; }
+
+protected:
+    void onRelease() override;
+    void onAbandon() override;
+
+private:
+    GrD3D11Attachment(GrD3D11Gpu* gpu,
+                    SkISize dimensions,
+                    UsageFlags supportedUsages,
+                    DXGI_FORMAT format,
+                    const D3D11_TEXTURE2D_DESC&,
+                    const GrD3D11TextureInfo&,
+                    ID3D11View* view,
+                    std::string_view label);
+
+    GrD3D11Gpu* getD3D11Gpu() const;
+
+    void onSetLabel() override;
+
+    DXGI_FORMAT fFormat;
+    gr_cp<ID3D11View> fView;
+    GrD3D11TextureInfo fInfo;
+};
+
+#endif
diff --git a/src/gpu/ganesh/d3d11/GrD3D11Buffer.cpp b/src/gpu/ganesh/d3d11/GrD3D11Buffer.cpp
new file mode 100644
index 0000000000..9a73b6a1ad
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11Buffer.cpp
@@ -0,0 +1,249 @@
+
+#include "src/gpu/ganesh/d3d11/GrD3D11Buffer.h"
+
+#ifdef SK_DEBUG
+#define VALIDATE() this->validate()
+#else
+#define VALIDATE() \
+    do {           \
+    } while (false)
+#endif
+
+static gr_cp<ID3D11Buffer> make_d3d11_buffer(GrD3D11Gpu* gpu,
+                                           size_t size,
+                                           GrGpuBufferType intendedType,
+                                           GrAccessPattern accessPattern) {
+    D3D11_USAGE usage;
+    if (accessPattern == kStatic_GrAccessPattern) {
+        SkASSERT(intendedType != GrGpuBufferType::kXferCpuToGpu &&
+                 intendedType != GrGpuBufferType::kXferGpuToCpu);
+
+        usage = D3D11_USAGE_DEFAULT;
+    } else {
+        if (intendedType == GrGpuBufferType::kXferGpuToCpu ||
+            intendedType == GrGpuBufferType::kXferCpuToGpu) {
+            usage = D3D11_USAGE_STAGING;
+        } else {
+            usage = D3D11_USAGE_DYNAMIC;
+        }
+    }
+
+    D3D11_BUFFER_DESC desc{};
+    desc.ByteWidth = size;
+    desc.Usage = usage;
+
+    if (usage == D3D11_USAGE_DYNAMIC)
+        desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
+    else if (usage == D3D11_USAGE_STAGING && intendedType == GrGpuBufferType::kXferGpuToCpu)
+        desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
+    else if (usage == D3D11_USAGE_STAGING && intendedType == GrGpuBufferType::kXferCpuToGpu)
+        desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
+
+    if (intendedType == GrGpuBufferType::kVertex)
+        desc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
+    else if (intendedType == GrGpuBufferType::kIndex)
+        desc.BindFlags = D3D11_BIND_INDEX_BUFFER;
+    else if (intendedType == GrGpuBufferType::kUniform) {
+        desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
+        desc.ByteWidth = SkAlignTo(size, 16);
+    }
+
+    gr_cp<ID3D11Buffer> resource;
+    HRESULT hr = gpu->device()->CreateBuffer(&desc, NULL, &resource);
+    GR_D3D_CALL_ERRCHECK(hr);
+    return resource;
+}
+
+sk_sp<GrD3D11Buffer> GrD3D11Buffer::Make(GrD3D11Gpu* gpu,
+                                     size_t size,
+                                     GrGpuBufferType intendedType,
+                                     GrAccessPattern accessPattern) {
+    gr_cp<ID3D11Buffer> resource = make_d3d11_buffer(gpu, size, intendedType, accessPattern);
+    if (!resource) {
+        return nullptr;
+    }
+
+    return sk_sp<GrD3D11Buffer>(new GrD3D11Buffer(gpu,
+                                              size,
+                                              intendedType,
+                                              accessPattern,
+                                              std::move(resource),
+                                              /*label=*/"MakeD3DBuffer"));
+}
+
+GrD3D11Buffer::GrD3D11Buffer(GrD3D11Gpu* gpu,
+                         size_t size,
+                         GrGpuBufferType intendedType,
+                         GrAccessPattern accessPattern,
+                         gr_cp<ID3D11Buffer> bufferResource,
+                         std::string_view label)
+        : INHERITED(gpu, size, intendedType, accessPattern, label)
+        , fD3D11Buffer(std::move(bufferResource)) {
+    this->registerWithCache(skgpu::Budgeted::kYes);
+
+    // TODO: persistently map UPLOAD resources?
+
+    VALIDATE();
+}
+
+void GrD3D11Buffer::releaseResource() {
+    if (this->wasDestroyed()) {
+        return;
+    }
+
+    if (fMapPtr) {
+        this->unmap();
+    }
+
+    SkASSERT(fStagingBuffer == nullptr);
+    SkASSERT(fD3D11Buffer);
+    fD3D11Buffer.reset();
+}
+
+void GrD3D11Buffer::onRelease() {
+    this->releaseResource();
+    this->INHERITED::onRelease();
+}
+
+void GrD3D11Buffer::onAbandon() {
+    this->releaseResource();
+    this->INHERITED::onAbandon();
+}
+
+void GrD3D11Buffer::onMap(MapType type) { 
+    fMapPtr = this->internalMap(type, 0, this->size()); 
+}
+
+void GrD3D11Buffer::onUnmap(MapType type) {
+    this->internalUnmap(type, 0, this->size()); 
+}
+
+bool GrD3D11Buffer::onClearToZero() { 
+    if (!fD3D11Buffer) {
+        return false;
+    }
+
+    if (accessPattern() == kStatic_GrAccessPattern) {
+        void* zeros = sk_calloc_throw(this->size());
+        this->onUpdateData(zeros, 0, this->size(), /*preserve=*/false);
+        sk_free(zeros);
+        return true;
+    }
+
+    void* ptr = this->internalMap(MapType::kWriteDiscard, 0, this->size());
+    if (!ptr) {
+        return false;
+    }
+    std::memset(ptr, 0, this->size());
+    this->internalUnmap(MapType::kWriteDiscard, 0, this->size());
+
+    return true;
+}
+
+bool GrD3D11Buffer::onUpdateData(const void* src,
+                                 size_t offset,
+                                 size_t size,
+                                 bool preserve) {
+    if (!fD3D11Buffer) {
+        return false;
+    }
+
+    if (accessPattern() == kStatic_GrAccessPattern) {
+        D3D11_BOX box;
+        box.back = 1;
+        box.front = 0;
+        box.top = 0;
+        box.bottom = 1;
+        box.left = offset;
+        box.right = offset + size;
+
+        // update the real vb buffer
+        getD3D11Gpu()->deviceContext()->UpdateSubresource(
+                fD3D11Buffer.get(), 0, &box, src, size, 0);
+
+        return true;
+    }
+
+    void* ptr = this->internalMap(MapType::kWriteDiscard, offset, size);
+    if (!ptr) {
+        return false;
+    }
+    memcpy(ptr, src, size);
+    this->internalUnmap(MapType::kWriteDiscard, offset, size);
+
+    return true;
+}
+
+void* GrD3D11Buffer::internalMap(MapType type, size_t offset, size_t size) {
+    // TODO: if UPLOAD heap type, could be persistently mapped (i.e., this would be a no-op)
+    SkASSERT(fD3D11Buffer);
+    SkASSERT(!this->isMapped());
+    SkASSERT(offset + size <= this->size());
+
+    VALIDATE();
+
+    void* res = nullptr;
+    if (this->accessPattern() == kStatic_GrAccessPattern) {
+        res = sk_calloc_throw(this->size());
+        fStagingBuffer = res;
+    } else {
+        D3D11_MAPPED_SUBRESOURCE mappedResource;
+
+        D3D11_MAP mapType;
+        if (type == MapType::kRead)
+            mapType = D3D11_MAP_READ;
+        else if (type == MapType::kWriteDiscard)
+            mapType = D3D11_MAP_WRITE_DISCARD;
+        else {
+            SkASSERT(false);
+            mapType = D3D11_MAP_WRITE;
+        }
+
+        if (intendedType() == GrGpuBufferType::kXferCpuToGpu) {
+            mapType = D3D11_MAP_WRITE;
+        }
+
+        UINT flags = 0;
+        auto hr = getD3D11Gpu()->deviceContext()->Map(fD3D11Buffer.get(), 0, mapType, flags, &mappedResource);
+        GR_D3D_CALL_ERRCHECK(hr);
+        res = mappedResource.pData;
+        SkASSERT(res);
+    }
+
+    if (res) {
+        res = SkTAddOffset<void>(res, offset);
+    }
+    VALIDATE();
+    return res;
+}
+
+void GrD3D11Buffer::internalUnmap(MapType type, size_t offset, size_t size) {
+    // TODO: if UPLOAD heap type, could be persistently mapped (i.e., this would be a no-op)
+    SkASSERT(fD3D11Buffer);
+    SkASSERT(offset + size <= this->size());
+    VALIDATE();
+
+    if (this->accessPattern() == kStatic_GrAccessPattern) {
+        SkASSERT(fStagingBuffer);
+        onUpdateData(fStagingBuffer, 0, this->size(), false);
+        sk_free(fStagingBuffer);
+        fStagingBuffer = nullptr;
+    } else {
+        getD3D11Gpu()->deviceContext()->Unmap(fD3D11Buffer.get(), 0);
+    }
+
+    VALIDATE();
+}
+
+void GrD3D11Buffer::onSetLabel() {
+    SkASSERT(fD3D11Buffer);
+    if (!this->getLabel().empty()) {
+        const std::string label = "_Skia_" + this->getLabel();
+        this->d3d11Resource()->SetPrivateData(WKPDID_D3DDebugObjectName, label.size(), label.c_str());
+    }
+}
+
+#ifdef SK_DEBUG
+void GrD3D11Buffer::validate() const {
+}
+#endif
diff --git a/src/gpu/ganesh/d3d11/GrD3D11Buffer.h b/src/gpu/ganesh/d3d11/GrD3D11Buffer.h
new file mode 100644
index 0000000000..cb15cbe46e
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11Buffer.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef GrD3D11Buffer_DEFINED
+#define GrD3D11Buffer_DEFINED
+
+#include "src/gpu/ganesh/GrCaps.h"
+#include "src/gpu/ganesh/GrGpuBuffer.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Gpu.h"
+
+class GrD3D11Buffer : public GrGpuBuffer {
+public:
+    static sk_sp<GrD3D11Buffer> Make(GrD3D11Gpu*, size_t size, GrGpuBufferType, GrAccessPattern);
+
+    ~GrD3D11Buffer() override { releaseResource(); }
+
+    ID3D11Buffer* d3d11Resource() const {
+        SkASSERT(fD3D11Buffer);
+        return fD3D11Buffer.get();
+    }
+
+protected:
+    GrD3D11Buffer(GrD3D11Gpu* gpu,
+                  size_t sizeInBytes,
+                  GrGpuBufferType type,
+                  GrAccessPattern accessPattern,
+                  gr_cp<ID3D11Buffer>,
+                  std::string_view label);
+
+    void onAbandon() override;
+    void onRelease() override;
+
+private:
+    void releaseResource();
+
+    void onMap(MapType) override;
+    void onUnmap(MapType) override;
+    bool onClearToZero() override;
+    bool onUpdateData(const void* src, size_t offset, size_t size, bool preserve) override;
+
+    void* internalMap(MapType, size_t offset, size_t size);
+    void internalUnmap(MapType, size_t offset, size_t size);
+
+#ifdef SK_DEBUG
+    void validate() const;
+#endif
+
+    void onSetLabel() override;
+
+    GrD3D11Gpu* getD3D11Gpu() const {
+        SkASSERT(!this->wasDestroyed());
+        return reinterpret_cast<GrD3D11Gpu*>(this->getGpu());
+    }
+
+    gr_cp<ID3D11Buffer> fD3D11Buffer;
+    void* fStagingBuffer = nullptr;
+
+    using INHERITED = GrGpuBuffer;
+};
+
+#endif
diff --git a/src/gpu/ganesh/d3d11/GrD3D11Caps.cpp b/src/gpu/ganesh/d3d11/GrD3D11Caps.cpp
new file mode 100644
index 0000000000..33125f4588
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11Caps.cpp
@@ -0,0 +1,1113 @@
+/*
+ * Copyright 2019 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "src/gpu/ganesh/d3d11/GrD3D11Caps.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Texture.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11RenderTarget.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11TextureRenderTarget.h"
+#include "src/gpu/ganesh/d3d/GrD3DUtil.h"
+
+#include "src/gpu/ganesh/GrProgramDesc.h"
+#include "src/gpu/ganesh/TestFormatColorTypeCombination.h"
+#include "src/gpu/ganesh/GrRenderTargetProxy.h"
+#include "src/core/SkCompressedDataUtils.h"
+#include "src/gpu/KeyBuilder.h"
+#include "src/gpu/ganesh/GrBackendUtils.h"
+#include "src/gpu/ganesh/GrProgramDesc.h"
+#include "src/gpu/ganesh/GrProgramInfo.h"
+#include "src/gpu/ganesh/GrRenderTargetProxy.h"
+#include "src/gpu/ganesh/GrShaderCaps.h"
+#include "src/gpu/ganesh/GrStencilSettings.h"
+
+#include "include/core/SkTextureCompressionType.h"
+
+GrD3D11Caps::GrD3D11Caps(const GrContextOptions& contextOptions,
+                     IDXGIAdapter1* adapter,
+                     ID3D11Device* device)
+        : INHERITED(contextOptions) {
+    /**************************************************************************
+     * GrCaps fields
+     **************************************************************************/
+    fNPOTTextureTileSupport = true;    // available in feature level 10_0 and up
+    fMipmapSupport = true;             // always available in Direct3D
+    fAnisoSupport = true;              // always available in Direct3D
+    fReuseScratchTextures = true;      // TODO: figure this out
+    fGpuTracingSupport = false;        // TODO: figure this out
+    fOversizedStencilSupport = false;  // TODO: figure this out
+    fDrawInstancedSupport = true;
+    fNativeDrawIndirectSupport = false;
+
+    fSemaphoreSupport = true;
+    fBackendSemaphoreSupport = true;
+    fFinishedProcAsyncCallbackSupport = true;
+    // TODO: implement these
+    fCrossContextTextureSupport = false;
+    fHalfFloatVertexAttributeSupport = false;
+
+    // We always copy in/out of a transfer buffer so it's trivial to support row bytes.
+    fReadPixelsRowBytesSupport = true;
+    fWritePixelsRowBytesSupport = true;
+    fTransferPixelsToRowBytesSupport = true;
+
+    //fTransferFromBufferToTextureSupport = true;
+    //fTransferFromSurfaceToBufferSupport = true;
+    fTransferFromBufferToBufferSupport = true;
+
+    fMaxRenderTargetSize = 16384;  // minimum required by feature level 11_0
+    fMaxTextureSize = 16384;       // minimum required by feature level 11_0
+
+    fTransferBufferRowBytesAlignment = 256;
+    
+    // TODO: implement
+    fDynamicStateArrayGeometryProcessorTextureSupport = false;
+
+    fShaderCaps = std::make_unique<GrShaderCaps>();
+
+    // D3D11 does not support scissor + clear
+    fPerformPartialClearsAsDraws = true;
+
+    this->init(contextOptions, adapter, device);
+}
+
+bool GrD3D11Caps::canCopyTexture(DXGI_FORMAT dstFormat,
+                               int dstSampleCnt,
+                               DXGI_FORMAT srcFormat,
+                               int srcSampleCnt) const {
+    if ((dstSampleCnt > 1 || srcSampleCnt > 1) && dstSampleCnt != srcSampleCnt) {
+        return false;
+    }
+
+    // D3D allows us to copy within the same format family but doesn't do conversions
+    // so we require strict identity.
+    return srcFormat == dstFormat;
+}
+
+bool GrD3D11Caps::canCopyAsResolve(DXGI_FORMAT dstFormat,
+                                 int dstSampleCnt,
+                                 DXGI_FORMAT srcFormat,
+                                 int srcSampleCnt) const {
+    // The src surface must be multisampled.
+    if (srcSampleCnt <= 1) {
+        return false;
+    }
+
+    // The dst must not be multisampled.
+    if (dstSampleCnt > 1) {
+        return false;
+    }
+
+    // Surfaces must have the same format.
+    // D3D12 can resolve between typeless and non-typeless formats, but we are not using
+    // typeless formats. It's not possible to resolve within the same format family otherwise.
+    if (srcFormat != dstFormat) {
+        return false;
+    }
+
+    return true;
+}
+
+bool GrD3D11Caps::onCanCopySurface(const GrSurfaceProxy* dst,
+                                 const SkIRect& dstRect,
+                                 const GrSurfaceProxy* src,
+                                 const SkIRect& srcRect) const {
+    // D3D12 does not support scaling copies
+    if (srcRect.size() != dstRect.size()) {
+        return false;
+    }
+    if (src->isProtected() == GrProtected::kYes && dst->isProtected() != GrProtected::kYes) {
+        return false;
+    }
+
+    int dstSampleCnt = 0;
+    int srcSampleCnt = 0;
+    if (const GrRenderTargetProxy* rtProxy = dst->asRenderTargetProxy()) {
+        dstSampleCnt = rtProxy->numSamples();
+    }
+    if (const GrRenderTargetProxy* rtProxy = src->asRenderTargetProxy()) {
+        srcSampleCnt = rtProxy->numSamples();
+    }
+    SkASSERT((dstSampleCnt > 0) == SkToBool(dst->asRenderTargetProxy()));
+    SkASSERT((srcSampleCnt > 0) == SkToBool(src->asRenderTargetProxy()));
+
+    DXGI_FORMAT dstFormat, srcFormat;
+    SkAssertResult(dst->backendFormat().asDxgiFormat(&dstFormat));
+    SkAssertResult(src->backendFormat().asDxgiFormat(&srcFormat));
+
+    return this->canCopyTexture(dstFormat, dstSampleCnt, srcFormat, srcSampleCnt) ||
+           this->canCopyAsResolve(dstFormat, dstSampleCnt, srcFormat, srcSampleCnt);
+}
+
+void GrD3D11Caps::init(const GrContextOptions& contextOptions,
+                     IDXGIAdapter1* adapter,
+                     ID3D11Device* device) {
+    DXGI_ADAPTER_DESC adapterDesc;
+    GR_D3D_CALL_ERRCHECK(adapter->GetDesc(&adapterDesc));
+
+    D3D11_FEATURE_DATA_D3D11_OPTIONS optionsDesc;
+    GR_D3D_CALL_ERRCHECK(device->CheckFeatureSupport(
+            D3D11_FEATURE_D3D11_OPTIONS, &optionsDesc, sizeof(optionsDesc)));
+
+    // See https://docs.microsoft.com/en-us/windows/win32/direct3d12/hardware-support
+    fMaxPerStageShaderResourceViews = 128;
+    fMaxPerStageUnorderedAccessViews = 64;
+
+    D3D11_FEATURE_DATA_D3D11_OPTIONS2 optionsDesc2;
+    GR_D3D_CALL_ERRCHECK(device->CheckFeatureSupport(
+            D3D11_FEATURE_D3D11_OPTIONS2, &optionsDesc2, sizeof(optionsDesc2)));
+
+    fStandardSwizzleLayoutSupport = optionsDesc2.StandardSwizzle;
+    fResolveSubresourceRegionSupport = true;
+
+    this->initGrCaps(optionsDesc2, device);
+    this->initShaderCaps(adapterDesc.VendorId, device);
+
+    this->initFormatTable(adapterDesc, device);
+    this->initStencilFormat(device);
+    
+    this->applyDriverCorrectnessWorkarounds(adapterDesc.VendorId);
+
+    this->finishInitialization(contextOptions);
+}
+
+void GrD3D11Caps::initGrCaps(const D3D11_FEATURE_DATA_D3D11_OPTIONS2& optionsDesc,
+                           ID3D11Device* device) {
+    // We assume a minimum of Shader Model 5.1, which allows at most 32 vertex inputs.
+    fMaxVertexAttributes = 32;
+
+    // Can use standard sample locations
+    fSampleLocationsSupport = true;
+
+   if (D3D11_CONSERVATIVE_RASTERIZATION_NOT_SUPPORTED !=
+        optionsDesc.ConservativeRasterizationTier) {
+        fConservativeRasterSupport = true;
+    }
+
+    fWireframeSupport = true;
+
+    // Feature level 11_0 and up support up to 16K in texture dimension
+    fMaxTextureSize = 16384;
+    // There's no specific cap for RT size, so use texture size
+    fMaxRenderTargetSize = fMaxTextureSize;
+    // Our render targets are always created with textures as the color
+    // attachment, hence this min:
+    fMaxRenderTargetSize = fMaxTextureSize;
+
+    fMaxPreferredRenderTargetSize = fMaxRenderTargetSize;
+
+    // Assuming since we will always map in the end to upload the data we might as well just map
+    // from the get go. There is no hard data to suggest this is faster or slower.
+    fBufferMapThreshold = 0;
+
+    fMapBufferFlags = kCanMap_MapFlag | kSubset_MapFlag | kAsyncRead_MapFlag;
+
+    fOversizedStencilSupport = true;
+
+    fTwoSidedStencilRefsAndMasksMustMatch = true;
+
+    // Advanced blend modes don't appear to be supported.
+}
+
+void GrD3D11Caps::initShaderCaps(int vendorID, ID3D11Device* device) {
+    GrShaderCaps* shaderCaps = fShaderCaps.get();
+    shaderCaps->fVersionDeclString = "#version 330\n";
+
+    // Shader Model 5 supports all of the following:
+    shaderCaps->fUsesPrecisionModifiers = true;
+    shaderCaps->fFlatInterpolationSupport = true;
+    // Flat interpolation appears to be slow on Qualcomm GPUs. This was tested in GL and is assumed
+    // to be true with D3D as well.
+    shaderCaps->fPreferFlatInterpolation = kQualcomm_D3DVendor != vendorID;
+
+    shaderCaps->fSampleMaskSupport = true;
+
+    shaderCaps->fShaderDerivativeSupport = true;
+    shaderCaps->fExplicitTextureLodSupport = true;
+
+    shaderCaps->fDualSourceBlendingSupport = true;
+
+    shaderCaps->fIntegerSupport = true;
+    shaderCaps->fNonsquareMatrixSupport = true;
+    // TODO(skia:12352) HLSL does not expose asinh/acosh/atanh
+    shaderCaps->fInverseHyperbolicSupport = false;
+    shaderCaps->fVertexIDSupport = true;
+    shaderCaps->fInfinitySupport = true;
+    shaderCaps->fNonconstantArrayIndexSupport = true;
+    shaderCaps->fBitManipulationSupport = true;
+
+    shaderCaps->fFloatIs32Bits = true;
+
+    /*
+    D3D11_FEATURE_DATA_SHADER_MIN_PRECISION_SUPPORT minPrecisionSupport;
+    GR_D3D11_CALL_ERRCHECK(device->CheckFeatureSupport(D3D11_FEATURE_SHADER_MIN_PRECISION_SUPPORT,
+                                                       &minPrecisionSupport,
+                                                       sizeof(minPrecisionSupport)));
+    */
+    shaderCaps->fHalfIs32Bits = true;
+
+    //D3D11_FEATURE_DATA_D3D11_OPTIONS5 options5;
+    //GR_D3D11_CALL_ERRCHECK(device->CheckFeatureSupport(D3D11_FEATURE_D3D11_OPTIONS5, &options5, sizeof(options5)));
+
+    //// See https://docs.microsoft.com/en-us/windows/win32/direct3d12/hardware-support
+    //// The maximum number of samplers in a shader-visible descriptor heap is 2048, but
+    //// 16 of those are reserved for the driver.
+
+    //shaderCaps->fMaxFragmentSamplers =
+    //        (D3D11_SHARED_RESOURCE_TIER_1 == options5.SharedResourceTier) ? 16 : 2032;
+
+    shaderCaps->fMaxFragmentSamplers = 2032;
+}
+
+void GrD3D11Caps::applyDriverCorrectnessWorkarounds(int vendorID) {
+    // Nothing yet.
+}
+
+bool stencil_format_supported(ID3D11Device* device, DXGI_FORMAT format) {
+    D3D11_FEATURE_DATA_FORMAT_SUPPORT formatSupportDesc;
+    formatSupportDesc.InFormat = format;
+    GR_D3D_CALL_ERRCHECK(device->CheckFeatureSupport(
+            D3D11_FEATURE_FORMAT_SUPPORT, &formatSupportDesc, sizeof(formatSupportDesc)));
+    return SkToBool(D3D11_FORMAT_SUPPORT_DEPTH_STENCIL & formatSupportDesc.OutFormatSupport);
+}
+
+void GrD3D11Caps::initStencilFormat(ID3D11Device* device) {
+    if (stencil_format_supported(device, DXGI_FORMAT_D24_UNORM_S8_UINT)) {
+        fPreferredStencilFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;
+    } else {
+        SkASSERT(stencil_format_supported(device, DXGI_FORMAT_D32_FLOAT_S8X24_UINT));
+        fPreferredStencilFormat = DXGI_FORMAT_D32_FLOAT_S8X24_UINT;
+    }
+}
+
+// These are all the valid DXGI_FORMATs that we support in Skia. They are roughly ordered from most
+// frequently used to least to improve look up times in arrays.
+static constexpr DXGI_FORMAT kDxgiFormats[] = {DXGI_FORMAT_R8G8B8A8_UNORM,
+                                               DXGI_FORMAT_R8_UNORM,
+                                               DXGI_FORMAT_B8G8R8A8_UNORM,
+                                               DXGI_FORMAT_B5G6R5_UNORM,
+                                               DXGI_FORMAT_R16G16B16A16_FLOAT,
+                                               DXGI_FORMAT_R16_FLOAT,
+                                               DXGI_FORMAT_R8G8_UNORM,
+                                               DXGI_FORMAT_R10G10B10A2_UNORM,
+                                               DXGI_FORMAT_B4G4R4A4_UNORM,
+                                               DXGI_FORMAT_R8G8B8A8_UNORM_SRGB,
+                                               DXGI_FORMAT_BC1_UNORM,
+                                               DXGI_FORMAT_R16_UNORM,
+                                               DXGI_FORMAT_R16G16_UNORM,
+                                               DXGI_FORMAT_R16G16B16A16_UNORM,
+                                               DXGI_FORMAT_R16G16_FLOAT};
+
+void GrD3D11Caps::setColorType(GrColorType colorType, std::initializer_list<DXGI_FORMAT> formats) {
+#ifdef SK_DEBUG
+    for (size_t i = 0; i < kNumDxgiFormats; ++i) {
+        const auto& formatInfo = fFormatTable[i];
+        for (int j = 0; j < formatInfo.fColorTypeInfoCount; ++j) {
+            const auto& ctInfo = formatInfo.fColorTypeInfos[j];
+            if (ctInfo.fColorType == colorType &&
+                !SkToBool(ctInfo.fFlags & ColorTypeInfo::kWrappedOnly_Flag)) {
+                bool found = false;
+                for (auto it = formats.begin(); it != formats.end(); ++it) {
+                    if (kDxgiFormats[i] == *it) {
+                        found = true;
+                    }
+                }
+                SkASSERT(found);
+            }
+        }
+    }
+#endif
+    int idx = static_cast<int>(colorType);
+    for (auto it = formats.begin(); it != formats.end(); ++it) {
+        const auto& info = this->getFormatInfo(*it);
+        for (int i = 0; i < info.fColorTypeInfoCount; ++i) {
+            if (info.fColorTypeInfos[i].fColorType == colorType) {
+                fColorTypeToFormatTable[idx] = *it;
+                return;
+            }
+        }
+    }
+}
+
+const GrD3D11Caps::FormatInfo& GrD3D11Caps::getFormatInfo(DXGI_FORMAT format) const {
+    GrD3D11Caps* nonConstThis = const_cast<GrD3D11Caps*>(this);
+    return nonConstThis->getFormatInfo(format);
+}
+
+GrD3D11Caps::FormatInfo& GrD3D11Caps::getFormatInfo(DXGI_FORMAT format) {
+    static_assert(std::size(kDxgiFormats) == GrD3D11Caps::kNumDxgiFormats,
+                  "Size of DXGI_FORMATs array must match static value in header");
+    for (size_t i = 0; i < std::size(kDxgiFormats); ++i) {
+        if (kDxgiFormats[i] == format) {
+            return fFormatTable[i];
+        }
+    }
+    static FormatInfo kInvalidFormat;
+    return kInvalidFormat;
+}
+
+void GrD3D11Caps::initFormatTable(const DXGI_ADAPTER_DESC& adapterDesc, ID3D11Device* device) {
+    static_assert(std::size(kDxgiFormats) == GrD3D11Caps::kNumDxgiFormats,
+                  "Size of DXGI_FORMATs array must match static value in header");
+
+    std::fill_n(fColorTypeToFormatTable, kGrColorTypeCnt, DXGI_FORMAT_UNKNOWN);
+
+    // Go through all the formats and init their support surface and data GrColorTypes.
+    // Format: DXGI_FORMAT_R8G8B8A8_UNORM
+    {
+        constexpr DXGI_FORMAT format = DXGI_FORMAT_R8G8B8A8_UNORM;
+        auto& info = this->getFormatInfo(format);
+        info.init(adapterDesc, device, format);
+        info.fFormatColorType = GrColorType::kRGBA_8888;
+        if (SkToBool(info.fFlags & FormatInfo::kTexturable_Flag)) {
+            info.fColorTypeInfoCount = 2;
+            info.fColorTypeInfos.reset(new ColorTypeInfo[info.fColorTypeInfoCount]());
+            int ctIdx = 0;
+            // Format: DXGI_FORMAT_R8G8B8A8_UNORM, Surface: kRGBA_8888
+            {
+                constexpr GrColorType ct = GrColorType::kRGBA_8888;
+                auto& ctInfo = info.fColorTypeInfos[ctIdx++];
+                ctInfo.fColorType = ct;
+                ctInfo.fFlags = ColorTypeInfo::kUploadData_Flag | ColorTypeInfo::kRenderable_Flag;
+            }
+            // Format: DXGI_FORMAT_R8G8B8A8_UNORM, Surface: kRGB_888x
+            {
+                constexpr GrColorType ct = GrColorType::kRGB_888x;
+                auto& ctInfo = info.fColorTypeInfos[ctIdx++];
+                ctInfo.fColorType = ct;
+                ctInfo.fFlags = ColorTypeInfo::kUploadData_Flag;
+                ctInfo.fReadSwizzle = skgpu::Swizzle("rgb1");
+            }
+        }
+    }
+
+    // Format: DXGI_FORMAT_R8_UNORM
+    {
+        constexpr DXGI_FORMAT format = DXGI_FORMAT_R8_UNORM;
+        auto& info = this->getFormatInfo(format);
+        info.init(adapterDesc, device, format);
+        info.fFormatColorType = GrColorType::kR_8;
+        if (SkToBool(info.fFlags & FormatInfo::kTexturable_Flag)) {
+            info.fColorTypeInfoCount = 3;
+            info.fColorTypeInfos.reset(new ColorTypeInfo[info.fColorTypeInfoCount]());
+            int ctIdx = 0;
+            // Format: DXGI_FORMAT_R8_UNORM, Surface: kR_8
+            {
+                constexpr GrColorType ct = GrColorType::kR_8;
+                auto& ctInfo = info.fColorTypeInfos[ctIdx++];
+                ctInfo.fColorType = ct;
+                ctInfo.fFlags = ColorTypeInfo::kUploadData_Flag | ColorTypeInfo::kRenderable_Flag;
+            }
+            // Format: DXGI_FORMAT_R8_UNORM, Surface: kAlpha_8
+            {
+                constexpr GrColorType ct = GrColorType::kAlpha_8;
+                auto& ctInfo = info.fColorTypeInfos[ctIdx++];
+                ctInfo.fColorType = ct;
+                ctInfo.fFlags = ColorTypeInfo::kUploadData_Flag | ColorTypeInfo::kRenderable_Flag;
+                ctInfo.fReadSwizzle = skgpu::Swizzle("000r");
+                ctInfo.fWriteSwizzle = skgpu::Swizzle("a000");
+            }
+            // Format: DXGI_FORMAT_R8_UNORM, Surface: kGray_8
+            {
+                constexpr GrColorType ct = GrColorType::kGray_8;
+                auto& ctInfo = info.fColorTypeInfos[ctIdx++];
+                ctInfo.fColorType = ct;
+                ctInfo.fFlags = ColorTypeInfo::kUploadData_Flag;
+                ctInfo.fReadSwizzle = skgpu::Swizzle("rrr1");
+            }
+        }
+    }
+    // Format: DXGI_FORMAT_B8G8R8A8_UNORM
+    {
+        constexpr DXGI_FORMAT format = DXGI_FORMAT_B8G8R8A8_UNORM;
+        auto& info = this->getFormatInfo(format);
+        info.init(adapterDesc, device, format);
+        info.fFormatColorType = GrColorType::kBGRA_8888;
+        if (SkToBool(info.fFlags & FormatInfo::kTexturable_Flag)) {
+            info.fColorTypeInfoCount = 1;
+            info.fColorTypeInfos.reset(new ColorTypeInfo[info.fColorTypeInfoCount]());
+            int ctIdx = 0;
+            // Format: DXGI_FORMAT_B8G8R8A8_UNORM, Surface: kBGRA_8888
+            {
+                constexpr GrColorType ct = GrColorType::kBGRA_8888;
+                auto& ctInfo = info.fColorTypeInfos[ctIdx++];
+                ctInfo.fColorType = ct;
+                ctInfo.fFlags = ColorTypeInfo::kUploadData_Flag | ColorTypeInfo::kRenderable_Flag;
+            }
+        }
+    }
+    // Format: DXGI_FORMAT_B5G6R5_UNORM
+    {
+        constexpr DXGI_FORMAT format = DXGI_FORMAT_B5G6R5_UNORM;
+        auto& info = this->getFormatInfo(format);
+        info.init(adapterDesc, device, format);
+        info.fFormatColorType = GrColorType::kBGR_565;
+        if (SkToBool(info.fFlags & FormatInfo::kTexturable_Flag)) {
+            info.fColorTypeInfoCount = 1;
+            info.fColorTypeInfos.reset(new ColorTypeInfo[info.fColorTypeInfoCount]());
+            int ctIdx = 0;
+            // Format: DXGI_FORMAT_B5G6R5_UNORM, Surface: kBGR_565
+            {
+                constexpr GrColorType ct = GrColorType::kBGR_565;
+                auto& ctInfo = info.fColorTypeInfos[ctIdx++];
+                ctInfo.fColorType = ct;
+                ctInfo.fFlags = ColorTypeInfo::kUploadData_Flag | ColorTypeInfo::kRenderable_Flag;
+            }
+        }
+    }
+    // Format: DXGI_FORMAT_R16G16B16A16_FLOAT
+    {
+        constexpr DXGI_FORMAT format = DXGI_FORMAT_R16G16B16A16_FLOAT;
+        auto& info = this->getFormatInfo(format);
+        info.init(adapterDesc, device, format);
+        info.fFormatColorType = GrColorType::kRGBA_F16;
+        if (SkToBool(info.fFlags & FormatInfo::kTexturable_Flag)) {
+            info.fColorTypeInfoCount = 2;
+            info.fColorTypeInfos.reset(new ColorTypeInfo[info.fColorTypeInfoCount]());
+            int ctIdx = 0;
+            // Format: DXGI_FORMAT_R16G16B16A16_FLOAT, Surface: GrColorType::kRGBA_F16
+            {
+                constexpr GrColorType ct = GrColorType::kRGBA_F16;
+                auto& ctInfo = info.fColorTypeInfos[ctIdx++];
+                ctInfo.fColorType = ct;
+                ctInfo.fFlags = ColorTypeInfo::kUploadData_Flag | ColorTypeInfo::kRenderable_Flag;
+            }
+            // Format: DXGI_FORMAT_R16G16B16A16_FLOAT, Surface: GrColorType::kRGBA_F16_Clamped
+            {
+                constexpr GrColorType ct = GrColorType::kRGBA_F16_Clamped;
+                auto& ctInfo = info.fColorTypeInfos[ctIdx++];
+                ctInfo.fColorType = ct;
+                ctInfo.fFlags = ColorTypeInfo::kUploadData_Flag | ColorTypeInfo::kRenderable_Flag;
+            }
+        }
+    }
+    // Format: DXGI_FORMAT_R16_FLOAT
+    {
+        constexpr DXGI_FORMAT format = DXGI_FORMAT_R16_FLOAT;
+        auto& info = this->getFormatInfo(format);
+        info.init(adapterDesc, device, format);
+        info.fFormatColorType = GrColorType::kR_F16;
+        if (SkToBool(info.fFlags & FormatInfo::kTexturable_Flag)) {
+            info.fColorTypeInfoCount = 1;
+            info.fColorTypeInfos.reset(new ColorTypeInfo[info.fColorTypeInfoCount]());
+            int ctIdx = 0;
+            // Format: DXGI_FORMAT_R16_FLOAT, Surface: kAlpha_F16
+            {
+                constexpr GrColorType ct = GrColorType::kAlpha_F16;
+                auto& ctInfo = info.fColorTypeInfos[ctIdx++];
+                ctInfo.fColorType = ct;
+                ctInfo.fFlags = ColorTypeInfo::kUploadData_Flag | ColorTypeInfo::kRenderable_Flag;
+                ctInfo.fReadSwizzle = skgpu::Swizzle("000r");
+                ctInfo.fWriteSwizzle = skgpu::Swizzle("a000");
+            }
+        }
+    }
+    // Format: DXGI_FORMAT_R8G8_UNORM
+    {
+        constexpr DXGI_FORMAT format = DXGI_FORMAT_R8G8_UNORM;
+        auto& info = this->getFormatInfo(format);
+        info.init(adapterDesc, device, format);
+        info.fFormatColorType = GrColorType::kRG_88;
+        if (SkToBool(info.fFlags & FormatInfo::kTexturable_Flag)) {
+            info.fColorTypeInfoCount = 1;
+            info.fColorTypeInfos.reset(new ColorTypeInfo[info.fColorTypeInfoCount]());
+            int ctIdx = 0;
+            // Format: DXGI_FORMAT_R8G8_UNORM, Surface: kRG_88
+            {
+                constexpr GrColorType ct = GrColorType::kRG_88;
+                auto& ctInfo = info.fColorTypeInfos[ctIdx++];
+                ctInfo.fColorType = ct;
+                ctInfo.fFlags = ColorTypeInfo::kUploadData_Flag | ColorTypeInfo::kRenderable_Flag;
+            }
+        }
+    }
+    // Format: DXGI_FORMAT_R10G10B10A2_UNORM
+    {
+        constexpr DXGI_FORMAT format = DXGI_FORMAT_R10G10B10A2_UNORM;
+        auto& info = this->getFormatInfo(format);
+        info.init(adapterDesc, device, format);
+        info.fFormatColorType = GrColorType::kRGBA_1010102;
+        if (SkToBool(info.fFlags & FormatInfo::kTexturable_Flag)) {
+            info.fColorTypeInfoCount = 1;
+            info.fColorTypeInfos.reset(new ColorTypeInfo[info.fColorTypeInfoCount]());
+            int ctIdx = 0;
+            // Format: DXGI_FORMAT_R10G10B10A2_UNORM, Surface: kRGBA_1010102
+            {
+                constexpr GrColorType ct = GrColorType::kRGBA_1010102;
+                auto& ctInfo = info.fColorTypeInfos[ctIdx++];
+                ctInfo.fColorType = ct;
+                ctInfo.fFlags = ColorTypeInfo::kUploadData_Flag | ColorTypeInfo::kRenderable_Flag;
+            }
+        }
+    }
+    // Format: DXGI_FORMAT_B4G4R4A4_UNORM
+    {
+        constexpr DXGI_FORMAT format = DXGI_FORMAT_B4G4R4A4_UNORM;
+        auto& info = this->getFormatInfo(format);
+        info.init(adapterDesc, device, format);
+        info.fFormatColorType = GrColorType::kBGRA_4444;
+        if (SkToBool(info.fFlags & FormatInfo::kTexturable_Flag)) {
+            info.fColorTypeInfoCount = 1;
+            info.fColorTypeInfos.reset(new ColorTypeInfo[info.fColorTypeInfoCount]());
+            int ctIdx = 0;
+            // Format: DXGI_FORMAT_B4G4R4A4_UNORM, Surface: kABGR_4444
+            {
+                constexpr GrColorType ct = GrColorType::kABGR_4444;
+                auto& ctInfo = info.fColorTypeInfos[ctIdx++];
+                ctInfo.fColorType = ct;
+                ctInfo.fFlags = ColorTypeInfo::kUploadData_Flag | ColorTypeInfo::kRenderable_Flag;
+                ctInfo.fReadSwizzle = skgpu::Swizzle("argb");
+                ctInfo.fWriteSwizzle = skgpu::Swizzle("gbar");
+            }
+        }
+    }
+    // Format: DXGI_FORMAT_R8G8B8A8_UNORM_SRGB
+    {
+        constexpr DXGI_FORMAT format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
+        auto& info = this->getFormatInfo(format);
+        info.init(adapterDesc, device, format);
+        info.fFormatColorType = GrColorType::kRGBA_8888_SRGB;
+        if (SkToBool(info.fFlags & FormatInfo::kTexturable_Flag)) {
+            info.fColorTypeInfoCount = 1;
+            info.fColorTypeInfos.reset(new ColorTypeInfo[info.fColorTypeInfoCount]());
+            int ctIdx = 0;
+            // Format: DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Surface: kRGBA_8888_SRGB
+            {
+                constexpr GrColorType ct = GrColorType::kRGBA_8888_SRGB;
+                auto& ctInfo = info.fColorTypeInfos[ctIdx++];
+                ctInfo.fColorType = ct;
+                ctInfo.fFlags = ColorTypeInfo::kUploadData_Flag | ColorTypeInfo::kRenderable_Flag;
+            }
+        }
+    }
+    // Format: DXGI_FORMAT_R16_UNORM
+    {
+        constexpr DXGI_FORMAT format = DXGI_FORMAT_R16_UNORM;
+        auto& info = this->getFormatInfo(format);
+        info.init(adapterDesc, device, format);
+        info.fFormatColorType = GrColorType::kR_16;
+        if (SkToBool(info.fFlags & FormatInfo::kTexturable_Flag)) {
+            info.fColorTypeInfoCount = 1;
+            info.fColorTypeInfos.reset(new ColorTypeInfo[info.fColorTypeInfoCount]());
+            int ctIdx = 0;
+            // Format: DXGI_FORMAT_R16_UNORM, Surface: kAlpha_16
+            {
+                constexpr GrColorType ct = GrColorType::kAlpha_16;
+                auto& ctInfo = info.fColorTypeInfos[ctIdx++];
+                ctInfo.fColorType = ct;
+                ctInfo.fFlags = ColorTypeInfo::kUploadData_Flag | ColorTypeInfo::kRenderable_Flag;
+                ctInfo.fReadSwizzle = skgpu::Swizzle("000r");
+                ctInfo.fWriteSwizzle = skgpu::Swizzle("a000");
+            }
+        }
+    }
+    // Format: DXGI_FORMAT_R16G16_UNORM
+    {
+        constexpr DXGI_FORMAT format = DXGI_FORMAT_R16G16_UNORM;
+        auto& info = this->getFormatInfo(format);
+        info.init(adapterDesc, device, format);
+        info.fFormatColorType = GrColorType::kRG_1616;
+        if (SkToBool(info.fFlags & FormatInfo::kTexturable_Flag)) {
+            info.fColorTypeInfoCount = 1;
+            info.fColorTypeInfos.reset(new ColorTypeInfo[info.fColorTypeInfoCount]());
+            int ctIdx = 0;
+            // Format: DXGI_FORMAT_R16G16_UNORM, Surface: kRG_1616
+            {
+                constexpr GrColorType ct = GrColorType::kRG_1616;
+                auto& ctInfo = info.fColorTypeInfos[ctIdx++];
+                ctInfo.fColorType = ct;
+                ctInfo.fFlags = ColorTypeInfo::kUploadData_Flag | ColorTypeInfo::kRenderable_Flag;
+            }
+        }
+    }
+    // Format: DXGI_FORMAT_R16G16B16A16_UNORM
+    {
+        constexpr DXGI_FORMAT format = DXGI_FORMAT_R16G16B16A16_UNORM;
+        auto& info = this->getFormatInfo(format);
+        info.init(adapterDesc, device, format);
+        info.fFormatColorType = GrColorType::kRGBA_16161616;
+        if (SkToBool(info.fFlags & FormatInfo::kTexturable_Flag)) {
+            info.fColorTypeInfoCount = 1;
+            info.fColorTypeInfos.reset(new ColorTypeInfo[info.fColorTypeInfoCount]());
+            int ctIdx = 0;
+            // Format: DXGI_FORMAT_R16G16B16A16_UNORM, Surface: kRGBA_16161616
+            {
+                constexpr GrColorType ct = GrColorType::kRGBA_16161616;
+                auto& ctInfo = info.fColorTypeInfos[ctIdx++];
+                ctInfo.fColorType = ct;
+                ctInfo.fFlags = ColorTypeInfo::kUploadData_Flag | ColorTypeInfo::kRenderable_Flag;
+            }
+        }
+    }
+    // Format: DXGI_FORMAT_R16G16_FLOAT
+    {
+        constexpr DXGI_FORMAT format = DXGI_FORMAT_R16G16_FLOAT;
+        auto& info = this->getFormatInfo(format);
+        info.init(adapterDesc, device, format);
+        info.fFormatColorType = GrColorType::kRG_F16;
+        if (SkToBool(info.fFlags & FormatInfo::kTexturable_Flag)) {
+            info.fColorTypeInfoCount = 1;
+            info.fColorTypeInfos.reset(new ColorTypeInfo[info.fColorTypeInfoCount]());
+            int ctIdx = 0;
+            // Format: DXGI_FORMAT_R16G16_FLOAT, Surface: kRG_F16
+            {
+                constexpr GrColorType ct = GrColorType::kRG_F16;
+                auto& ctInfo = info.fColorTypeInfos[ctIdx++];
+                ctInfo.fColorType = ct;
+                ctInfo.fFlags = ColorTypeInfo::kUploadData_Flag | ColorTypeInfo::kRenderable_Flag;
+            }
+        }
+    }
+
+    // Format: DXGI_FORMAT_BC1_UNORM
+    {
+        constexpr DXGI_FORMAT format = DXGI_FORMAT_BC1_UNORM;
+        auto& info = this->getFormatInfo(format);
+        info.init(adapterDesc, device, format);
+        // No supported GrColorTypes.
+    }
+
+    ////////////////////////////////////////////////////////////////////////////
+    // Map GrColorTypes (used for creating GrSurfaces) to DXGI_FORMATs. The order in which the
+    // formats are passed into the setColorType function indicates the priority in selecting which
+    // format we use for a given GrcolorType.
+
+    this->setColorType(GrColorType::kAlpha_8, {DXGI_FORMAT_R8_UNORM});
+    this->setColorType(GrColorType::kBGR_565, {DXGI_FORMAT_B5G6R5_UNORM});
+    this->setColorType(GrColorType::kABGR_4444, {DXGI_FORMAT_B4G4R4A4_UNORM});
+    this->setColorType(GrColorType::kRGBA_8888, {DXGI_FORMAT_R8G8B8A8_UNORM});
+    this->setColorType(GrColorType::kRGBA_8888_SRGB, {DXGI_FORMAT_R8G8B8A8_UNORM_SRGB});
+    this->setColorType(GrColorType::kRGB_888x, {DXGI_FORMAT_R8G8B8A8_UNORM});
+    this->setColorType(GrColorType::kRG_88, {DXGI_FORMAT_R8G8_UNORM});
+    this->setColorType(GrColorType::kBGRA_8888, {DXGI_FORMAT_B8G8R8A8_UNORM});
+    this->setColorType(GrColorType::kRGBA_1010102, {DXGI_FORMAT_R10G10B10A2_UNORM});
+    this->setColorType(GrColorType::kGray_8, {DXGI_FORMAT_R8_UNORM});
+    this->setColorType(GrColorType::kAlpha_F16, {DXGI_FORMAT_R16_FLOAT});
+    this->setColorType(GrColorType::kRGBA_F16, {DXGI_FORMAT_R16G16B16A16_FLOAT});
+    this->setColorType(GrColorType::kRGBA_F16_Clamped, {DXGI_FORMAT_R16G16B16A16_FLOAT});
+    this->setColorType(GrColorType::kAlpha_16, {DXGI_FORMAT_R16_UNORM});
+    this->setColorType(GrColorType::kRG_1616, {DXGI_FORMAT_R16G16_UNORM});
+    this->setColorType(GrColorType::kRGBA_16161616, {DXGI_FORMAT_R16G16B16A16_UNORM});
+    this->setColorType(GrColorType::kRG_F16, {DXGI_FORMAT_R16G16_FLOAT});
+}
+
+void GrD3D11Caps::FormatInfo::InitFormatFlags(const D3D11_FEATURE_DATA_FORMAT_SUPPORT& formatSupport,
+                                            uint16_t* flags) {
+    if (SkToBool(D3D11_FORMAT_SUPPORT_SHADER_SAMPLE & formatSupport.OutFormatSupport)) {
+        *flags = *flags | kTexturable_Flag;
+
+        // Ganesh assumes that all renderable surfaces are also texturable
+        if (SkToBool(D3D11_FORMAT_SUPPORT_RENDER_TARGET & formatSupport.OutFormatSupport) &&
+            SkToBool(D3D11_FORMAT_SUPPORT_BLENDABLE & formatSupport.OutFormatSupport)) {
+            *flags = *flags | kRenderable_Flag;
+        }
+    }
+
+    if (SkToBool(D3D11_FORMAT_SUPPORT_MULTISAMPLE_RENDERTARGET & formatSupport.OutFormatSupport)) {
+        *flags = *flags | kMSAA_Flag;
+    }
+
+    if (SkToBool(D3D11_FORMAT_SUPPORT_MULTISAMPLE_RESOLVE & formatSupport.OutFormatSupport)) {
+        *flags = *flags | kResolve_Flag;
+    }
+
+    if (SkToBool(D3D11_FORMAT_SUPPORT_TYPED_UNORDERED_ACCESS_VIEW &
+                 formatSupport.OutFormatSupport)) {
+        *flags = *flags | kUnorderedAccess_Flag;
+    }
+}
+
+static bool multisample_count_supported(ID3D11Device* device, DXGI_FORMAT format, int sampleCount) {
+    UINT NumQualityLevels;
+    GR_D3D_CALL_ERRCHECK(
+            device->CheckMultisampleQualityLevels(format, sampleCount, &NumQualityLevels));
+
+    return NumQualityLevels > 0;
+}
+
+void GrD3D11Caps::FormatInfo::initSampleCounts(const DXGI_ADAPTER_DESC& adapterDesc,
+                                             ID3D11Device* device,
+                                             DXGI_FORMAT format) {
+    if (multisample_count_supported(device, format, 1)) {
+        fColorSampleCounts.push_back(1);
+    }
+    // TODO: test these
+    // if (kImagination_D3DVendor == adapterDesc.VendorId) {
+    //    // MSAA does not work on imagination
+    //    return;
+    //}
+    // if (kIntel_D3DVendor == adapterDesc.VendorId) {
+    //    // MSAA doesn't work well on Intel GPUs chromium:527565, chromium:983926
+    //    return;
+    //}
+    if (multisample_count_supported(device, format, 2)) {
+        fColorSampleCounts.push_back(2);
+    }
+    if (multisample_count_supported(device, format, 4)) {
+        fColorSampleCounts.push_back(4);
+    }
+    if (multisample_count_supported(device, format, 8)) {
+        fColorSampleCounts.push_back(8);
+    }
+    if (multisample_count_supported(device, format, 16)) {
+        fColorSampleCounts.push_back(16);
+    }
+    // Standard sample locations are not defined for more than 16 samples, and we don't need more
+    // than 16. Omit 32 and 64.
+}
+
+void GrD3D11Caps::FormatInfo::init(const DXGI_ADAPTER_DESC& adapterDesc,
+                                 ID3D11Device* device,
+                                 DXGI_FORMAT format) {
+    D3D11_FEATURE_DATA_FORMAT_SUPPORT formatSupportDesc;
+    formatSupportDesc.InFormat = format;
+    GR_D3D_CALL_ERRCHECK(device->CheckFeatureSupport(
+            D3D11_FEATURE_FORMAT_SUPPORT, &formatSupportDesc, sizeof(formatSupportDesc)));
+
+    InitFormatFlags(formatSupportDesc, &fFlags);
+    if (fFlags & kRenderable_Flag) {
+        this->initSampleCounts(adapterDesc, device, format);
+    }
+}
+
+bool GrD3D11Caps::isFormatSRGB(const GrBackendFormat& format) const {
+    DXGI_FORMAT dxgiFormat;
+    if (!format.asDxgiFormat(&dxgiFormat)) {
+        return false;
+    }
+
+    switch (dxgiFormat) {
+        case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool GrD3D11Caps::isFormatTexturable(const GrBackendFormat& format, GrTextureType) const {
+    DXGI_FORMAT dxgiFormat;
+    if (!format.asDxgiFormat(&dxgiFormat)) {
+        return false;
+    }
+
+    return this->isFormatTexturable(dxgiFormat);
+}
+
+bool GrD3D11Caps::isFormatTexturable(DXGI_FORMAT format) const {
+    const FormatInfo& info = this->getFormatInfo(format);
+    return SkToBool(FormatInfo::kTexturable_Flag & info.fFlags);
+}
+
+bool GrD3D11Caps::isFormatAsColorTypeRenderable(GrColorType ct,
+                                              const GrBackendFormat& format,
+                                              int sampleCount) const {
+    DXGI_FORMAT dxgiFormat;
+    if (!format.asDxgiFormat(&dxgiFormat)) {
+        return false;
+    }
+    if (!this->isFormatRenderable(dxgiFormat, sampleCount)) {
+        return false;
+    }
+    const auto& info = this->getFormatInfo(dxgiFormat);
+    if (!SkToBool(info.colorTypeFlags(ct) & ColorTypeInfo::kRenderable_Flag)) {
+        return false;
+    }
+    return true;
+}
+
+bool GrD3D11Caps::isFormatRenderable(const GrBackendFormat& format, int sampleCount) const {
+    DXGI_FORMAT dxgiFormat;
+    if (!format.asDxgiFormat(&dxgiFormat)) {
+        return false;
+    }
+    return this->isFormatRenderable(dxgiFormat, sampleCount);
+}
+
+bool GrD3D11Caps::isFormatRenderable(DXGI_FORMAT format, int sampleCount) const {
+    return sampleCount <= this->maxRenderTargetSampleCount(format);
+}
+
+bool GrD3D11Caps::isFormatUnorderedAccessible(DXGI_FORMAT format) const {
+    const FormatInfo& info = this->getFormatInfo(format);
+    return SkToBool(FormatInfo::kUnorderedAccess_Flag & info.fFlags);
+}
+
+int GrD3D11Caps::getRenderTargetSampleCount(int requestedCount, const GrBackendFormat& format) const {
+    DXGI_FORMAT dxgiFormat;
+    if (!format.asDxgiFormat(&dxgiFormat)) {
+        return 0;
+    }
+
+    return this->getRenderTargetSampleCount(requestedCount, dxgiFormat);
+}
+
+int GrD3D11Caps::getRenderTargetSampleCount(int requestedCount, DXGI_FORMAT format) const {
+    requestedCount = std::max(1, requestedCount);
+
+    const FormatInfo& info = this->getFormatInfo(format);
+
+    int count = info.fColorSampleCounts.size();
+
+    if (!count) {
+        return 0;
+    }
+
+    if (1 == requestedCount) {
+        SkASSERT(info.fColorSampleCounts.size() && info.fColorSampleCounts[0] == 1);
+        return 1;
+    }
+
+    for (int i = 0; i < count; ++i) {
+        if (info.fColorSampleCounts[i] >= requestedCount) {
+            return info.fColorSampleCounts[i];
+        }
+    }
+    return 0;
+}
+
+int GrD3D11Caps::maxRenderTargetSampleCount(const GrBackendFormat& format) const {
+    DXGI_FORMAT dxgiFormat;
+    if (!format.asDxgiFormat(&dxgiFormat)) {
+        return 0;
+    }
+    return this->maxRenderTargetSampleCount(dxgiFormat);
+}
+
+int GrD3D11Caps::maxRenderTargetSampleCount(DXGI_FORMAT format) const {
+    const FormatInfo& info = this->getFormatInfo(format);
+
+    const auto& table = info.fColorSampleCounts;
+    if (!table.size()) {
+        return 0;
+    }
+    return table[table.size() - 1];
+}
+
+GrColorType GrD3D11Caps::getFormatColorType(DXGI_FORMAT format) const {
+    const FormatInfo& info = this->getFormatInfo(format);
+    return info.fFormatColorType;
+}
+
+GrCaps::SupportedWrite GrD3D11Caps::supportedWritePixelsColorType(
+        GrColorType surfaceColorType,
+        const GrBackendFormat& surfaceFormat,
+        GrColorType srcColorType) const {
+    DXGI_FORMAT dxgiFormat;
+    if (!surfaceFormat.asDxgiFormat(&dxgiFormat)) {
+        return {GrColorType::kUnknown, 0};
+    }
+
+    // Any buffer data needs to be aligned to 512 bytes and that of a single texel.
+    size_t offsetAlignment = SkAlignTo(GrDxgiFormatBytesPerBlock(dxgiFormat),
+                                       512);
+
+    const auto& info = this->getFormatInfo(dxgiFormat);
+    for (int i = 0; i < info.fColorTypeInfoCount; ++i) {
+        const auto& ctInfo = info.fColorTypeInfos[i];
+        if (ctInfo.fColorType == surfaceColorType) {
+            return {surfaceColorType, offsetAlignment};
+        }
+    }
+    return {GrColorType::kUnknown, 0};
+}
+
+GrCaps::SurfaceReadPixelsSupport GrD3D11Caps::surfaceSupportsReadPixels(
+        const GrSurface* surface) const {
+    if (surface->isProtected()) {
+        return SurfaceReadPixelsSupport::kUnsupported;
+    }
+    if (auto tex = static_cast<const GrD3D11Texture*>(surface->asTexture())) {
+        // We can't directly read from a compressed format
+        if (GrDxgiFormatIsCompressed(tex->dxgiFormat())) {
+            return SurfaceReadPixelsSupport::kCopyToTexture2D;
+        }
+        return SurfaceReadPixelsSupport::kSupported;
+    } else if (auto rt = static_cast<const GrD3D11RenderTarget*>(surface->asRenderTarget())) {
+        if (rt->numSamples() > 1) {
+            return SurfaceReadPixelsSupport::kCopyToTexture2D;
+        }
+        return SurfaceReadPixelsSupport::kSupported;
+    }
+    return SurfaceReadPixelsSupport::kUnsupported;
+}
+
+bool GrD3D11Caps::onSurfaceSupportsWritePixels(const GrSurface* surface) const {
+    if (auto rt = surface->asRenderTarget()) {
+        return rt->numSamples() <= 1 && SkToBool(surface->asTexture());
+    }
+    return true;
+}
+
+bool GrD3D11Caps::onAreColorTypeAndFormatCompatible(GrColorType ct,
+                                                  const GrBackendFormat& format) const {
+    DXGI_FORMAT dxgiFormat;
+    if (!format.asDxgiFormat(&dxgiFormat)) {
+        return false;
+    }
+
+    const auto& info = this->getFormatInfo(dxgiFormat);
+    for (int i = 0; i < info.fColorTypeInfoCount; ++i) {
+        if (info.fColorTypeInfos[i].fColorType == ct) {
+            return true;
+        }
+    }
+    return false;
+}
+
+GrBackendFormat GrD3D11Caps::onGetDefaultBackendFormat(GrColorType ct) const {
+    DXGI_FORMAT format = this->getFormatFromColorType(ct);
+    if (format == DXGI_FORMAT_UNKNOWN) {
+        return {};
+    }
+    return GrBackendFormat::MakeDxgi(format);
+}
+
+GrBackendFormat GrD3D11Caps::getBackendFormatFromCompressionType(
+        SkTextureCompressionType compressionType) const {
+    switch (compressionType) {
+        case SkTextureCompressionType::kBC1_RGBA8_UNORM:
+            if (this->isFormatTexturable(DXGI_FORMAT_BC1_UNORM)) {
+                return GrBackendFormat::MakeDxgi(DXGI_FORMAT_BC1_UNORM);
+            }
+            return {};
+        default:
+            return {};
+    }
+
+    SkUNREACHABLE;
+}
+
+skgpu::Swizzle GrD3D11Caps::onGetReadSwizzle(const GrBackendFormat& format,
+                                           GrColorType colorType) const {
+    DXGI_FORMAT dxgiFormat;
+    SkAssertResult(format.asDxgiFormat(&dxgiFormat));
+    const auto& info = this->getFormatInfo(dxgiFormat);
+    for (int i = 0; i < info.fColorTypeInfoCount; ++i) {
+        const auto& ctInfo = info.fColorTypeInfos[i];
+        if (ctInfo.fColorType == colorType) {
+            return ctInfo.fReadSwizzle;
+        }
+    }
+    SkDEBUGFAILF("Illegal color type (%d) and format (%d) combination.",
+                 (int)colorType,
+                 (int)dxgiFormat);
+    return {};
+}
+
+skgpu::Swizzle GrD3D11Caps::getWriteSwizzle(const GrBackendFormat& format,
+                                          GrColorType colorType) const {
+    DXGI_FORMAT dxgiFormat;
+    SkAssertResult(format.asDxgiFormat(&dxgiFormat));
+    const auto& info = this->getFormatInfo(dxgiFormat);
+    for (int i = 0; i < info.fColorTypeInfoCount; ++i) {
+        const auto& ctInfo = info.fColorTypeInfos[i];
+        if (ctInfo.fColorType == colorType) {
+            return ctInfo.fWriteSwizzle;
+        }
+    }
+    SkDEBUGFAILF("Illegal color type (%d) and format (%d) combination.",
+                 (int)colorType,
+                 (int)dxgiFormat);
+    return {};
+}
+
+uint64_t GrD3D11Caps::computeFormatKey(const GrBackendFormat& format) const {
+    DXGI_FORMAT dxgiFormat;
+    SkAssertResult(format.asDxgiFormat(&dxgiFormat));
+
+    return (uint64_t)dxgiFormat;
+}
+
+GrCaps::SupportedRead GrD3D11Caps::onSupportedReadPixelsColorType(
+        GrColorType srcColorType,
+        const GrBackendFormat& srcBackendFormat,
+        GrColorType dstColorType) const {
+    DXGI_FORMAT dxgiFormat;
+    if (!srcBackendFormat.asDxgiFormat(&dxgiFormat)) {
+        return { GrColorType::kUnknown, 0 };
+    }
+
+    SkTextureCompressionType compression = GrBackendFormatToCompressionType(srcBackendFormat);
+    if (compression != SkTextureCompressionType::kNone) {
+        return { SkTextureCompressionTypeIsOpaque(compression) ? GrColorType::kRGB_888x
+                                                        : GrColorType::kRGBA_8888, 0 };
+    }
+
+    // Any subresource buffer data offset we copy to needs to be aligned to 512 bytes.
+    size_t offsetAlignment = 512;
+
+    const auto& info = this->getFormatInfo(dxgiFormat);
+    for (int i = 0; i < info.fColorTypeInfoCount; ++i) {
+        const auto& ctInfo = info.fColorTypeInfos[i];
+        if (ctInfo.fColorType == srcColorType) {
+            return { srcColorType, offsetAlignment };
+        }
+    }
+    return { GrColorType::kUnknown, 0 };
+}
+
+void GrD3D11Caps::addExtraSamplerKey(skgpu::KeyBuilder* b,
+                                   GrSamplerState samplerState,
+                                   const GrBackendFormat& format) const {
+    // TODO
+}
+
+/**
+ * TODO: Determine what goes in the ProgramDesc
+ */
+GrProgramDesc GrD3D11Caps::makeDesc(GrRenderTarget* rt,
+                                  const GrProgramInfo& programInfo,
+                                  ProgramDescOverrideFlags overrideFlags) const {
+    SkASSERT(overrideFlags == ProgramDescOverrideFlags::kNone);
+    GrProgramDesc desc;
+    GrProgramDesc::Build(&desc, programInfo, *this);
+
+    skgpu::KeyBuilder b(desc.key());
+
+    GrD3D11RenderTarget* d3dRT = (GrD3D11RenderTarget*)rt;
+    d3dRT->genKey(&b);
+
+    GrStencilSettings stencil = programInfo.nonGLStencilSettings();
+    stencil.genKey(&b, false);
+
+    programInfo.pipeline().genKey(&b, *this);
+    // The num samples is already added in the render target key so we don't need to add it here.
+
+    // D3D requires the full primitive type as part of its key
+    b.add32(programInfo.primitiveTypeKey());
+
+    b.flush();
+    return desc;
+}
+
+#if defined(GPU_TEST_UTILS)
+std::vector<GrTest::TestFormatColorTypeCombination> GrD3D11Caps::getTestingCombinations() const {
+    std::vector<GrTest::TestFormatColorTypeCombination> combos = {
+            {GrColorType::kAlpha_8, GrBackendFormat::MakeDxgi(DXGI_FORMAT_R8_UNORM)},
+            {GrColorType::kBGR_565, GrBackendFormat::MakeDxgi(DXGI_FORMAT_B5G6R5_UNORM)},
+            {GrColorType::kABGR_4444, GrBackendFormat::MakeDxgi(DXGI_FORMAT_B4G4R4A4_UNORM)},
+            {GrColorType::kRGBA_8888, GrBackendFormat::MakeDxgi(DXGI_FORMAT_R8G8B8A8_UNORM)},
+            {GrColorType::kRGBA_8888_SRGB,
+             GrBackendFormat::MakeDxgi(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB)},
+            {GrColorType::kRGB_888x, GrBackendFormat::MakeDxgi(DXGI_FORMAT_R8G8B8A8_UNORM)},
+            {GrColorType::kRG_88, GrBackendFormat::MakeDxgi(DXGI_FORMAT_R8G8_UNORM)},
+            {GrColorType::kBGRA_8888, GrBackendFormat::MakeDxgi(DXGI_FORMAT_B8G8R8A8_UNORM)},
+            {GrColorType::kRGBA_1010102, GrBackendFormat::MakeDxgi(DXGI_FORMAT_R10G10B10A2_UNORM)},
+            {GrColorType::kGray_8, GrBackendFormat::MakeDxgi(DXGI_FORMAT_R8_UNORM)},
+            {GrColorType::kAlpha_F16, GrBackendFormat::MakeDxgi(DXGI_FORMAT_R16_FLOAT)},
+            {GrColorType::kRGBA_F16, GrBackendFormat::MakeDxgi(DXGI_FORMAT_R16G16B16A16_FLOAT)},
+            {GrColorType::kRGBA_F16_Clamped,
+             GrBackendFormat::MakeDxgi(DXGI_FORMAT_R16G16B16A16_FLOAT)},
+            {GrColorType::kAlpha_16, GrBackendFormat::MakeDxgi(DXGI_FORMAT_R16_UNORM)},
+            {GrColorType::kRG_1616, GrBackendFormat::MakeDxgi(DXGI_FORMAT_R16G16_UNORM)},
+            {GrColorType::kRGBA_16161616,
+             GrBackendFormat::MakeDxgi(DXGI_FORMAT_R16G16B16A16_UNORM)},
+            {GrColorType::kRG_F16, GrBackendFormat::MakeDxgi(DXGI_FORMAT_R16G16_FLOAT)},
+            {GrColorType::kRGBA_8888, GrBackendFormat::MakeDxgi(DXGI_FORMAT_BC1_UNORM)},
+    };
+
+    return combos;
+}
+#endif
diff --git a/src/gpu/ganesh/d3d11/GrD3D11Caps.h b/src/gpu/ganesh/d3d11/GrD3D11Caps.h
new file mode 100644
index 0000000000..1f0f748e49
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11Caps.h
@@ -0,0 +1,222 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef GrD3D11Caps_DEFINED
+#define GrD3D11Caps_DEFINED
+
+#include "include/gpu/ganesh/d3d11/GrD3D11Types.h"
+#include "src/gpu/ganesh/GrCaps.h"
+#include "src/gpu/ganesh/SkGr.h"
+#include "include/private/base/SkTDArray.h"
+
+enum class SkTextureCompressionType;
+
+class GrD3D11Caps : public GrCaps {
+public:
+public:
+    /**
+     * Creates a GrD3DCaps that is set such that nothing is supported. The init function should
+     * be called to fill out the caps.
+     */
+    GrD3D11Caps(const GrContextOptions& contextOptions, IDXGIAdapter1*, ID3D11Device*);
+
+    bool isFormatSRGB(const GrBackendFormat&) const override;
+
+    bool isFormatTexturable(const GrBackendFormat&, GrTextureType) const override;
+    bool isFormatTexturable(DXGI_FORMAT) const;
+
+    bool isFormatCopyable(const GrBackendFormat&) const override { return true; }
+
+    bool isFormatAsColorTypeRenderable(GrColorType ct,
+                                       const GrBackendFormat& format,
+                                       int sampleCount = 1) const override;
+    bool isFormatRenderable(const GrBackendFormat& format, int sampleCount) const override;
+    bool isFormatRenderable(DXGI_FORMAT, int sampleCount) const;
+
+    bool isFormatUnorderedAccessible(DXGI_FORMAT) const;
+
+    int getRenderTargetSampleCount(int requestedCount, const GrBackendFormat&) const override;
+    int getRenderTargetSampleCount(int requestedCount, DXGI_FORMAT) const;
+
+    int maxRenderTargetSampleCount(const GrBackendFormat&) const override;
+    int maxRenderTargetSampleCount(DXGI_FORMAT) const;
+
+    GrColorType getFormatColorType(DXGI_FORMAT) const;
+
+    SupportedWrite supportedWritePixelsColorType(GrColorType surfaceColorType,
+                                                 const GrBackendFormat& surfaceFormat,
+                                                 GrColorType srcColorType) const override;
+
+    SurfaceReadPixelsSupport surfaceSupportsReadPixels(const GrSurface*) const override;
+
+    /**
+     * Returns both a supported and most preferred stencil format to use in draws.
+     */
+    DXGI_FORMAT preferredStencilFormat() const { return fPreferredStencilFormat; }
+    static int GetStencilFormatTotalBitCount(DXGI_FORMAT format) {
+        switch (format) {
+            case DXGI_FORMAT_D24_UNORM_S8_UINT:
+                return 32;
+            case DXGI_FORMAT_D32_FLOAT_S8X24_UINT:
+                // DXGI_FORMAT_D32_FLOAT_S8X24_UINT has 24 unused bits at the end so total bits
+                // is 64.
+                return 64;
+            default:
+                SkASSERT(false);
+                return 0;
+        }
+    }
+
+    /**
+     * Helpers used by canCopySurface. In all cases if the SampleCnt parameter is zero that means
+     * the surface is not a render target, otherwise it is the number of samples in the render
+     * target.
+     */
+    bool canCopyTexture(DXGI_FORMAT dstFormat,
+                        int dstSampleCnt,
+                        DXGI_FORMAT srcFormat,
+                        int srcSamplecnt) const;
+
+    bool canCopyAsResolve(DXGI_FORMAT dstFormat,
+                          int dstSampleCnt,
+                          DXGI_FORMAT srcFormat,
+                          int srcSamplecnt) const;
+
+    GrBackendFormat getBackendFormatFromCompressionType(SkTextureCompressionType) const override;
+
+    DXGI_FORMAT getFormatFromColorType(GrColorType colorType) const {
+        int idx = static_cast<int>(colorType);
+        return fColorTypeToFormatTable[idx];
+    }
+
+    skgpu::Swizzle getWriteSwizzle(const GrBackendFormat&, GrColorType) const override;
+
+    uint64_t computeFormatKey(const GrBackendFormat&) const override;
+
+    void addExtraSamplerKey(skgpu::KeyBuilder*,
+                            GrSamplerState,
+                            const GrBackendFormat&) const override;
+
+    GrProgramDesc makeDesc(GrRenderTarget*,
+                           const GrProgramInfo&,
+                           ProgramDescOverrideFlags) const override;
+
+    bool resolveSubresourceRegionSupport() const { return fResolveSubresourceRegionSupport; }
+    bool standardSwizzleLayoutSupport() const { return fStandardSwizzleLayoutSupport; }
+
+#if defined(GPU_TEST_UTILS)
+    std::vector<GrTest::TestFormatColorTypeCombination> getTestingCombinations() const override;
+#endif
+
+private:
+    enum D3DVendor {
+        kAMD_D3DVendor = 0x1002,
+        kARM_D3DVendor = 0x13B5,
+        kImagination_D3DVendor = 0x1010,
+        kIntel_D3DVendor = 0x8086,
+        kNVIDIA_D3DVendor = 0x10DE,
+        kQualcomm_D3DVendor = 0x5143,
+    };
+
+    void init(const GrContextOptions& contextOptions, IDXGIAdapter1*, ID3D11Device*);
+
+    void initGrCaps(const D3D11_FEATURE_DATA_D3D11_OPTIONS2&, ID3D11Device*);
+    void initShaderCaps(int vendorID, ID3D11Device* device);
+
+    void initFormatTable(const DXGI_ADAPTER_DESC&, ID3D11Device*);
+    void initStencilFormat(ID3D11Device*);
+
+    void applyDriverCorrectnessWorkarounds(int vendorID);
+
+    bool onSurfaceSupportsWritePixels(const GrSurface*) const override;
+    bool onCanCopySurface(const GrSurfaceProxy* dst,
+                          const SkIRect& dstRect,
+                          const GrSurfaceProxy* src,
+                          const SkIRect& srcRect) const override;
+    GrBackendFormat onGetDefaultBackendFormat(GrColorType) const override;
+
+    bool onAreColorTypeAndFormatCompatible(GrColorType, const GrBackendFormat&) const override;
+
+    SupportedRead onSupportedReadPixelsColorType(GrColorType,
+                                                 const GrBackendFormat&,
+                                                 GrColorType) const override;
+
+    skgpu::Swizzle onGetReadSwizzle(const GrBackendFormat&, GrColorType) const override;
+
+    // ColorTypeInfo for a specific format
+    struct ColorTypeInfo {
+        GrColorType fColorType = GrColorType::kUnknown;
+        enum {
+            kUploadData_Flag = 0x1,
+            // Does Ganesh itself support rendering to this colorType & format pair. Renderability
+            // still additionally depends on if the format itself is renderable.
+            kRenderable_Flag = 0x2,
+            // Indicates that this colorType is supported only if we are wrapping a texture with
+            // the given format and colorType. We do not allow creation with this pair.
+            kWrappedOnly_Flag = 0x4,
+        };
+        uint32_t fFlags = 0;
+
+        skgpu::Swizzle fReadSwizzle;
+        skgpu::Swizzle fWriteSwizzle;
+    };
+
+    struct FormatInfo {
+        uint32_t colorTypeFlags(GrColorType colorType) const {
+            for (int i = 0; i < fColorTypeInfoCount; ++i) {
+                if (fColorTypeInfos[i].fColorType == colorType) {
+                    return fColorTypeInfos[i].fFlags;
+                }
+            }
+            return 0;
+        }
+
+        void init(const DXGI_ADAPTER_DESC&, ID3D11Device*, DXGI_FORMAT);
+        static void InitFormatFlags(const D3D11_FEATURE_DATA_FORMAT_SUPPORT&, uint16_t* flags);
+        void initSampleCounts(const DXGI_ADAPTER_DESC& adapterDesc, ID3D11Device*, DXGI_FORMAT);
+
+        enum {
+            kTexturable_Flag = 0x1,  // Can be sampled in a shader
+            kRenderable_Flag = 0x2,  // Rendertarget and blendable
+            kMSAA_Flag = 0x4,
+            kResolve_Flag = 0x8,
+            kUnorderedAccess_Flag = 0x10,
+        };
+
+        uint16_t fFlags = 0;
+
+        SkTDArray<int> fColorSampleCounts;
+
+        // This GrColorType represents how the actually GPU format lays out its memory. This is used
+        // for uploading data to backend textures to make sure we've arranged the memory in the
+        // correct order.
+        GrColorType fFormatColorType = GrColorType::kUnknown;
+
+        std::unique_ptr<ColorTypeInfo[]> fColorTypeInfos;
+        int fColorTypeInfoCount = 0;
+    };
+    static const size_t kNumDxgiFormats = 15;
+    FormatInfo fFormatTable[kNumDxgiFormats];
+
+    FormatInfo& getFormatInfo(DXGI_FORMAT);
+    const FormatInfo& getFormatInfo(DXGI_FORMAT) const;
+
+    DXGI_FORMAT fColorTypeToFormatTable[kGrColorTypeCnt];
+    void setColorType(GrColorType, std::initializer_list<DXGI_FORMAT> formats);
+
+    int fMaxPerStageShaderResourceViews;
+    int fMaxPerStageUnorderedAccessViews;
+
+    DXGI_FORMAT fPreferredStencilFormat;
+
+    bool fResolveSubresourceRegionSupport : 1;
+    bool fStandardSwizzleLayoutSupport : 1;
+
+    using INHERITED = GrCaps;
+};
+
+#endif
diff --git a/src/gpu/ganesh/d3d11/GrD3D11Gpu.cpp b/src/gpu/ganesh/d3d11/GrD3D11Gpu.cpp
new file mode 100644
index 0000000000..af8f377f07
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11Gpu.cpp
@@ -0,0 +1,1112 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "src/core/SkCompressedDataUtils.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Gpu.h"
+
+#include "src/gpu/ganesh/GrThreadSafePipelineBuilder.h"
+#include "src/core/SkMipmap.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Attachment.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Buffer.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Caps.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11OpsRenderPass.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Texture.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11RenderTarget.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11TextureRenderTarget.h"
+#include "src/gpu/ganesh/d3d/GrD3DUtil.h"
+
+#include "include/gpu/ganesh/d3d/GrD3DBackendContext.h"
+
+#if defined(GPU_TEST_UTILS)
+#include <DXProgrammableCapture.h>
+#endif
+
+GrThreadSafePipelineBuilder* GrD3D11Gpu::pipelineBuilder() { 
+    return nullptr; 
+}
+
+sk_sp<GrThreadSafePipelineBuilder> GrD3D11Gpu::refPipelineBuilder() { 
+    return nullptr; 
+}
+
+std::unique_ptr<GrGpu> GrD3D11Gpu::Make(GrDirectContext* direct,
+                              const GrContextOptions& contextOptions,
+                              const GrD3DBackendContext& backendContext) {
+    return std::unique_ptr<GrGpu>(new GrD3D11Gpu(direct, contextOptions, backendContext));
+}
+
+GrD3D11Gpu::GrD3D11Gpu(GrDirectContext* direct,
+                       const GrContextOptions& contextOptions,
+                       const GrD3DBackendContext& backendContext)
+        :INHERITED(direct), fResourceProvider(this) {
+    auto device = (ID3D11Device*)backendContext.fD3D11Device;
+    auto deviceContext = (ID3D11DeviceContext*)backendContext.fD3D11DeviceContext;
+
+    fDevice.retain(device);
+    fDeviceContext.retain(deviceContext);
+
+    IDXGIDevice* pDXGIDevice;
+    auto hr = device->QueryInterface(__uuidof(IDXGIDevice), (void**)&pDXGIDevice);
+    GR_D3D_CALL_ERRCHECK(hr);
+
+    IDXGIAdapter1* adapter1 = nullptr;
+    IDXGIAdapter* adapter;
+    hr = pDXGIDevice->GetAdapter(&adapter);
+    GR_D3D_CALL_ERRCHECK(hr);
+
+    hr = adapter->QueryInterface(__uuidof(IDXGIAdapter1), (void**)&adapter1);
+    GR_D3D_CALL_ERRCHECK(hr);
+
+    this->initCaps(
+            sk_make_sp<GrD3D11Caps>(contextOptions, adapter1, fDevice.get()));
+
+    adapter1->Release();
+    adapter->Release();
+    pDXGIDevice->Release();
+
+#if defined(GPU_TEST_UTILS)
+    HRESULT getAnalysis = DXGIGetDebugInterface1(0, IID_PPV_ARGS(&fGraphicsAnalysis));
+    if (FAILED(getAnalysis)) {
+        fGraphicsAnalysis = nullptr;
+    }
+#endif
+}
+
+GrD3D11Gpu::~GrD3D11Gpu() {
+    destroyResources();
+}
+
+void GrD3D11Gpu::destroyResources() {
+    fResourceProvider.destroyResources();
+    fDeviceContext.reset();
+    fDevice.reset();
+#if defined(GPU_TEST_UTILS)
+    GrSafeComRelease(fGraphicsAnalysis);
+#endif
+}
+
+GrOpsRenderPass* GrD3D11Gpu::onGetOpsRenderPass(GrRenderTarget* rt,
+                                               bool /*useMSAASurface*/,
+                                               GrAttachment*,
+                                               GrSurfaceOrigin origin,
+                                               const SkIRect& bounds,
+                                               const GrOpsRenderPass::LoadAndStoreInfo& colorInfo,
+                                               const GrOpsRenderPass::StencilLoadAndStoreInfo& stencilInfo,
+                                               const skia_private::TArray<GrSurfaceProxy*,true>& sampledProxies,
+                                               GrXferBarrierFlags renderPassXferBarriers) {
+    if (!fCachedOpsRenderPass) {
+        fCachedOpsRenderPass.reset(new GrD3D11OpsRenderPass(this));
+    }
+
+    if (!fCachedOpsRenderPass->set(rt, origin, bounds, colorInfo, stencilInfo, sampledProxies)) {
+        return nullptr;
+    }
+
+    return fCachedOpsRenderPass.get();
+}
+
+void GrD3D11Gpu::submit(GrOpsRenderPass* renderPass) {
+    SkASSERT(fCachedOpsRenderPass.get() == renderPass);
+
+    fCachedOpsRenderPass->submit();
+    fCachedOpsRenderPass.reset();
+}
+
+void GrD3D11Gpu::endRenderPass(GrRenderTarget* target,
+                             GrSurfaceOrigin origin,
+                             const SkIRect& bounds) {
+    this->didWriteToSurface(target, origin, &bounds);
+}
+
+void GrD3D11Gpu::addFinishedProc(GrGpuFinishedProc finishedProc,
+                               GrGpuFinishedContext finishedContext) {
+    SkASSERT(finishedProc);
+    finishedProc(finishedContext);
+}
+
+sk_sp<GrD3D11Texture> GrD3D11Gpu::createD3D11Texture(SkISize dimensions,
+                                               DXGI_FORMAT dxgiFormat,
+                                               GrRenderable renderable,
+                                               int renderTargetSampleCnt,
+                                               skgpu::Budgeted budgeted,
+                                               GrProtected isProtected,
+                                               int mipLevelCount,
+                                               GrMipmapStatus mipmapStatus,
+                                               std::string_view label) {
+    
+    D3D11_USAGE usage = D3D11_USAGE_DEFAULT;
+    UINT bindFlags = D3D11_BIND_SHADER_RESOURCE;
+    UINT cpuFlags = 0;
+    UINT miscFlags = 0;
+
+    if (renderable == GrRenderable::kYes) {
+        bindFlags |= D3D11_BIND_RENDER_TARGET;
+        //bindFlags |= D3D11_BIND_DEPTH_STENCIL;
+    }
+
+    // This desc refers to a texture that will be read by the client. Thus even if msaa is
+    // requested, this describes the resolved texture. Therefore we always have samples set
+    // to 1.
+    SkASSERT(mipLevelCount > 0);
+    D3D11_TEXTURE2D_DESC resourceDesc = {};
+    resourceDesc.Width = dimensions.fWidth;
+    resourceDesc.Height = dimensions.fHeight;
+    resourceDesc.MipLevels = mipLevelCount;
+    resourceDesc.Format = dxgiFormat;
+    resourceDesc.SampleDesc.Count = 1;
+    resourceDesc.SampleDesc.Quality = 0;
+    resourceDesc.Usage = usage;
+    resourceDesc.BindFlags = bindFlags;
+    resourceDesc.CPUAccessFlags = cpuFlags;
+    resourceDesc.MiscFlags = miscFlags;
+    resourceDesc.ArraySize = 1;
+
+    if (renderable == GrRenderable::kYes) {
+        resourceDesc.BindFlags |= D3D11_BIND_RENDER_TARGET;
+        if (mipLevelCount > 1 && mipmapStatus != GrMipmapStatus::kValid) {
+            resourceDesc.MiscFlags |= D3D11_RESOURCE_MISC_GENERATE_MIPS;
+        }
+        return GrD3D11TextureRenderTarget::MakeNewTextureRenderTarget(this,
+                                                                    budgeted,
+                                                                    dimensions,
+                                                                    renderTargetSampleCnt,
+                                                                    resourceDesc,
+                                                                    isProtected,
+                                                                    mipmapStatus,
+                                                                    label);
+    } else {
+        if (mipLevelCount > 1 && mipmapStatus != GrMipmapStatus::kValid) {
+            resourceDesc.MiscFlags |= D3D11_RESOURCE_MISC_GENERATE_MIPS;
+            resourceDesc.BindFlags |= D3D11_BIND_RENDER_TARGET;
+        }
+        return GrD3D11Texture::MakeNewTexture(
+                this, budgeted, dimensions, resourceDesc, isProtected, mipmapStatus, label);
+    }
+}
+
+sk_sp<GrTexture> GrD3D11Gpu::onCreateTexture(SkISize dimensions,
+                                            const GrBackendFormat& format,
+                                            GrRenderable renderable,
+                                            int renderTargetSampleCnt,
+                                            skgpu::Budgeted budgeted,
+                                            GrProtected isProtected,
+                                            int mipLevelCount,
+                                            uint32_t levelClearMask,
+                                            std::string_view label) {
+
+    DXGI_FORMAT dxgiFormat;
+    SkAssertResult(format.asDxgiFormat(&dxgiFormat));
+    SkASSERT(!GrDxgiFormatIsCompressed(dxgiFormat));
+
+    GrMipmapStatus mipmapStatus =
+            mipLevelCount > 1 ? GrMipmapStatus::kDirty : GrMipmapStatus::kNotAllocated;
+
+    sk_sp<GrD3D11Texture> tex = this->createD3D11Texture(dimensions,
+                                                     dxgiFormat,
+                                                     renderable,
+                                                     renderTargetSampleCnt,
+                                                     budgeted,
+                                                     isProtected,
+                                                     mipLevelCount,
+                                                     mipmapStatus,
+                                                     label);
+    if (!tex) {
+        return nullptr;
+    }
+
+    if (levelClearMask) {
+        // TODO
+    }
+
+    return std::move(tex);
+}
+
+// TODO: why no 'isProtected' ?!
+sk_sp<GrTexture> GrD3D11Gpu::onCreateCompressedTexture(SkISize dimensions,
+                                                      const GrBackendFormat& format,
+                                                      skgpu::Budgeted budgeted,
+                                                      skgpu::Mipmapped mipmapped,
+                                                      GrProtected isProtected,
+                                                      const void* data, size_t dataSize) {
+    DXGI_FORMAT dxgiFormat;
+    SkAssertResult(format.asDxgiFormat(&dxgiFormat));
+    SkASSERT(GrDxgiFormatIsCompressed(dxgiFormat));
+
+    SkTextureCompressionType compressionType = GrBackendFormatToCompressionType(format);
+    SkASSERT(dataSize == SkCompressedFormatDataSize(
+                                 compressionType, dimensions, mipmapped == skgpu::Mipmapped::kYes));
+
+    int mipLevelCount = 1;
+    if (mipmapped == skgpu::Mipmapped::kYes) {
+        mipLevelCount = SkMipmap::ComputeLevelCount(dimensions.width(), dimensions.height()) + 1;
+    }
+    GrMipmapStatus mipmapStatus =
+            mipLevelCount > 1 ? GrMipmapStatus::kValid : GrMipmapStatus::kNotAllocated;
+
+    sk_sp<GrD3D11Texture> d3d11Tex = this->createD3D11Texture(dimensions,
+                                                        dxgiFormat,
+                                                        GrRenderable::kNo,
+                                                        1,
+                                                        budgeted,
+                                                        isProtected,
+                                                        mipLevelCount,
+                                                        mipmapStatus,
+                                                        /*label=*/"D3DGpu_CreateCompressedTexture");
+    if (!d3d11Tex) {
+        return nullptr;
+    }
+
+    ID3D11Texture2D* d3d11Resource = d3d11Tex->d3d11Resource();
+    SkASSERT(d3d11Resource);
+    D3D11_TEXTURE2D_DESC desc; 
+    d3d11Resource->GetDesc(&desc);
+
+    // Either upload only the first miplevel or all miplevels
+    SkASSERT(1 == mipLevelCount || mipLevelCount == (int)desc.MipLevels);
+
+    SkIRect rect;
+    rect.setXYWH(0, 0, dimensions.width(), dimensions.height());
+
+    GrMipLevel mipLevels[32];
+    
+    const char* ptr = (const char*)data;
+    for (int i = 0; i < mipLevelCount; ++i) {
+        size_t levelDataSize = SkCompressedDataSize(compressionType, dimensions, nullptr, false);
+
+        mipLevels[i].fPixels = ptr;
+        mipLevels[i].fRowBytes = levelDataSize / dimensions.height(); 
+        ptr += levelDataSize;
+        dimensions = {std::max(1, dimensions.width() / 2), std::max(1, dimensions.height() / 2)};
+    }
+
+    uploadToTexture(d3d11Tex.get(), rect, mipLevels, mipLevelCount);
+    return d3d11Tex;
+}
+
+static int get_surface_sample_cnt(GrSurface* surf) {
+    if (const GrRenderTarget* rt = surf->asRenderTarget()) {
+        return rt->numSamples();
+    }
+    return 0;
+}
+
+bool GrD3D11Gpu::onCopySurface(GrSurface* dst,
+                             const SkIRect& dstRect,
+                             GrSurface* src,
+                             const SkIRect& srcRect,
+                             GrSamplerState::Filter) {
+    if (srcRect.size() != dstRect.size()) {
+        return false;
+    }
+    if (src->isProtected() && !dst->isProtected()) {
+        SkDebugf("Can't copy from protected memory to non-protected");
+        return false;
+    }
+
+    int dstSampleCnt = get_surface_sample_cnt(dst);
+    int srcSampleCnt = get_surface_sample_cnt(src);
+
+    DXGI_FORMAT dstFormat;
+    ID3D11Texture2D* dstTexResource;
+    GrD3D11RenderTarget* dstRT = (GrD3D11RenderTarget*)dst->asRenderTarget();
+    if (dstRT) {
+        dstFormat = dstRT->dxgiFormat();
+        dstTexResource = dstRT->d3d11Resource();
+    } else {
+        SkASSERT(dst->asTexture());
+        GrD3D11Texture* dstTex = static_cast<GrD3D11Texture*>(dst->asTexture());
+        dstFormat = dstTex->dxgiFormat();
+        dstTexResource = dstTex->d3d11Resource();
+    }
+
+    DXGI_FORMAT srcFormat;
+    ID3D11Texture2D* srcTexResource;
+    GrD3D11RenderTarget* srcRT = (GrD3D11RenderTarget*)src->asRenderTarget();
+    if (srcRT) {
+        srcFormat = srcRT->dxgiFormat();
+        srcTexResource = srcRT->d3d11Resource();
+    } else {
+        SkASSERT(src->asTexture());
+        GrD3D11Texture* srcTex = static_cast<GrD3D11Texture*>(src->asTexture());
+        srcFormat = srcTex->dxgiFormat();
+        srcTexResource = srcTex->d3d11Resource();
+    }
+
+    const SkIPoint dstPoint = dstRect.topLeft();
+    if (this->d3d11Caps().canCopyAsResolve(dstFormat, dstSampleCnt, srcFormat, srcSampleCnt)) {
+        this->copySurfaceAsResolve(dst, src, srcRect, dstPoint);
+        return true;
+    }
+
+    if (this->d3d11Caps().canCopyTexture(dstFormat, dstSampleCnt, srcFormat, srcSampleCnt)) {
+        this->copySurfaceAsCopyTexture(dst, src, dstTexResource, srcTexResource, srcRect, dstPoint);
+        return true;
+    }
+
+    return false;
+}
+
+void GrD3D11Gpu::copySurfaceAsCopyTexture(GrSurface* dst,
+                                        GrSurface* src,
+                                        ID3D11Texture2D* dstResource,
+                                        ID3D11Texture2D* srcResource,
+                                        const SkIRect& srcRect,
+                                        const SkIPoint& dstPoint) {
+#ifdef SK_DEBUG
+    int dstSampleCnt = get_surface_sample_cnt(dst);
+    int srcSampleCnt = get_surface_sample_cnt(src);
+    DXGI_FORMAT dstFormat;
+    DXGI_FORMAT srcFormat;
+    dst->backendFormat().asDxgiFormat(&dstFormat);
+    SkAssertResult(dst->backendFormat().asDxgiFormat(&srcFormat));
+    SkASSERT(this->d3d11Caps().canCopyTexture(dstFormat, dstSampleCnt, srcFormat, srcSampleCnt));
+#endif
+
+    if (src->isProtected() && !dst->isProtected()) {
+        SkDebugf("Can't copy from protected memory to non-protected");
+        return;
+    }
+
+    D3D11_BOX srcBox = {};
+    srcBox.left = srcRect.fLeft;
+    srcBox.top = srcRect.fTop;
+    srcBox.right = srcRect.fRight;
+    srcBox.bottom = srcRect.fBottom;
+    srcBox.front = 0;
+    srcBox.back = 1;
+
+    deviceContext()->CopySubresourceRegion(
+            dstResource, 0, dstPoint.fX, dstPoint.fY, 0, srcResource, 0, &srcBox);
+
+    SkIRect dstRect =
+            SkIRect::MakeXYWH(dstPoint.fX, dstPoint.fY, srcRect.width(), srcRect.height());
+    // The rect is already in device space so we pass in kTopLeft so no flip is done.
+    this->didWriteToSurface(dst, kTopLeft_GrSurfaceOrigin, &dstRect);
+}
+
+void GrD3D11Gpu::copySurfaceAsResolve(GrSurface* dst,
+                                    GrSurface* src,
+                                    const SkIRect& srcRect,
+                                    const SkIPoint& dstPoint) {
+    GrD3D11RenderTarget* srcRT = static_cast<GrD3D11RenderTarget*>(src->asRenderTarget());
+    SkASSERT(srcRT);
+
+    this->resolveTexture(dst, dstPoint.fX, dstPoint.fY, srcRT, srcRect);
+    SkIRect dstRect =
+            SkIRect::MakeXYWH(dstPoint.fX, dstPoint.fY, srcRect.width(), srcRect.height());
+    // The rect is already in device space so we pass in kTopLeft so no flip is done.
+    this->didWriteToSurface(dst, kTopLeft_GrSurfaceOrigin, &dstRect);
+}
+
+void GrD3D11Gpu::resolveTexture(GrSurface* dst,
+                              int32_t dstX,
+                              int32_t dstY,
+                              GrD3D11RenderTarget* src,
+                              const SkIRect& srcIRect) {
+    SkASSERT(dst);
+    SkASSERT(src && src->numSamples() > 1);
+
+    //D3D11_RECT srcRect = {srcIRect.fLeft, srcIRect.fTop, srcIRect.fRight, srcIRect.fBottom};
+
+    //ID3D11Texture2D* dstResource = nullptr;
+    //deviceContext()->ResolveSubresource(dstResource, 0, src->getInfo().fTexture.get(), 0, src->dxgiFormat());
+    SkASSERT(false);
+}
+
+void GrD3D11Gpu::onResolveRenderTarget(GrRenderTarget* target, const SkIRect& resolveRect) {
+    SkASSERT(target->numSamples() > 1);
+    GrD3D11RenderTarget* rt = static_cast<GrD3D11RenderTarget*>(target);
+    //SkASSERT(rt->msaaTextureResource() && rt != rt->msaaTextureResource());
+
+    this->resolveTexture(target, resolveRect.fLeft, resolveRect.fTop, rt, resolveRect);
+}
+
+bool GrD3D11Gpu::onReadPixels(GrSurface* surface,
+                              SkIRect rect,
+                              GrColorType surfaceColorType,
+                              GrColorType dstColorType,
+                              void* buffer,
+                              size_t rowBytes) {
+    SkASSERT(surface);
+
+    if (surfaceColorType != dstColorType) {
+        return false;
+    }
+
+    // Copy back to CPU buffer
+    size_t bpp = GrColorTypeBytesPerPixel(dstColorType);
+    size_t tightRowBytes = bpp * rect.width();
+
+    ID3D11Texture2D* texResource = nullptr;
+    DXGI_FORMAT format;
+    GrD3D11RenderTarget* rt = static_cast<GrD3D11RenderTarget*>(surface->asRenderTarget());
+    if (rt) {
+        texResource = rt->d3d11Resource();
+        format = rt->dxgiFormat();
+    } else {
+        GrD3D11Texture* tex = static_cast<GrD3D11Texture*>(surface->asTexture());
+        texResource = tex->d3d11Resource();
+        format = tex->dxgiFormat();
+    }
+
+    if (!texResource) {
+        return false;
+    }
+
+    if (GrDxgiFormatBytesPerBlock(format) != bpp) {
+        return false;
+    }
+
+    D3D11_TEXTURE2D_DESC desc = {};
+    texResource->GetDesc(&desc);
+    desc.Usage = D3D11_USAGE_STAGING;
+    desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
+    desc.BindFlags = 0;
+    desc.MiscFlags = 0;
+
+    gr_cp<ID3D11Texture2D> stagingTex;
+    auto hr = device()->CreateTexture2D(&desc, nullptr, &stagingTex);
+    GR_D3D_CALL_ERRCHECK(hr);
+    deviceContext()->CopyResource(stagingTex.get(), texResource);
+
+    D3D11_MAPPED_SUBRESOURCE mapInfo;
+    hr = deviceContext()->Map(stagingTex.get(), 0, D3D11_MAP_READ, 0, &mapInfo);
+    GR_D3D_CALL_ERRCHECK(hr);
+    SkRectMemcpy(buffer, rowBytes, mapInfo.pData, mapInfo.RowPitch, tightRowBytes, rect.height());
+    deviceContext()->Unmap(stagingTex.get(), 0);
+
+    return true;
+}
+
+bool GrD3D11Gpu::onWritePixels(GrSurface* surface,
+                               SkIRect rect,
+                               GrColorType surfaceColorType,
+                               GrColorType srcColorType,
+                               const GrMipLevel texels[],
+                               int mipLevelCount,
+                               bool prepForTexSampling) {
+    GrD3D11Texture* d3dTex = static_cast<GrD3D11Texture*>(surface->asTexture());
+    if (!d3dTex) {
+        return false;
+    }
+
+    // Make sure we have at least the base level
+    if (!mipLevelCount || !texels[0].fPixels) {
+        return false;
+    }
+
+    SkASSERT(!GrDxgiFormatIsCompressed(d3dTex->dxgiFormat()));
+    bool success = false;
+
+    SkASSERT(mipLevelCount <= d3dTex->maxMipmapLevel() + 1);
+    success = this->uploadToTexture(d3dTex, rect, texels, mipLevelCount);
+
+    return success;
+}
+
+bool GrD3D11Gpu::uploadToTexture(GrD3D11Texture* tex,
+                                 SkIRect rect,
+                                 const GrMipLevel* texels,
+                                 int mipLevelCount) {
+    SkASSERT(this->d3d11Caps().isFormatTexturable(tex->dxgiFormat()));
+
+    // The assumption is either that we have no mipmaps, or that our rect is the entire texture
+    SkASSERT(mipLevelCount == 1 || rect == SkIRect::MakeSize(tex->dimensions()));
+
+    // We assume that if the texture has mip levels, we either upload to all the levels or just the
+    // first.
+    SkASSERT(mipLevelCount == 1 || mipLevelCount == (tex->maxMipmapLevel() + 1));
+
+    if (rect.isEmpty()) {
+        return false;
+    }
+
+    //SkASSERT(this->d3d11Caps().surfaceSupportsWritePixels(tex));
+
+    ID3D11Texture2D* d3d11Resource = tex->d3d11Resource();
+    SkASSERT(d3d11Resource);
+    D3D11_TEXTURE2D_DESC desc;
+    d3d11Resource->GetDesc(&desc);
+    bool ret = uploadToTexture(d3d11Resource, rect, texels, mipLevelCount);
+
+    if (ret && mipLevelCount < (int)desc.MipLevels) {
+        tex->markMipmapsDirty();
+    }
+
+    return ret;
+}
+
+bool GrD3D11Gpu::uploadToTexture(ID3D11Texture2D* d3d11Resource,
+                     SkIRect rect,
+                     const GrMipLevel texels[],
+                     int mipLevelCount) {
+    SkASSERT(d3d11Resource);
+    D3D11_TEXTURE2D_DESC desc;
+    d3d11Resource->GetDesc(&desc);
+
+    // Either upload only the first miplevel or all miplevels
+    SkASSERT(1 == mipLevelCount || mipLevelCount == (int)desc.MipLevels);
+
+    if (1 == mipLevelCount && !texels[0].fPixels) {
+        return true;  // no data to upload
+    }
+
+    for (int i = 0; i < mipLevelCount; ++i) {
+        // We do not allow any gaps in the mip data
+        if (!texels[i].fPixels) {
+            return false;
+        }
+    }
+
+    D3D11_BOX dstBox;
+    dstBox.left = rect.fLeft;
+    dstBox.right = rect.fRight;
+    dstBox.top = rect.fTop;
+    dstBox.bottom = rect.fBottom;
+    dstBox.front = 0;
+    dstBox.back = 1;
+    for (int i = 0; i < mipLevelCount; ++i) {
+        // We do not allow any gaps in the mip data
+        if (!texels[i].fPixels) {
+            return false;
+        }
+
+        deviceContext()->UpdateSubresource(d3d11Resource,
+                                           i,
+                                           i == 0 ? &dstBox : nullptr,
+                                           texels[i].fPixels,
+                                           texels[i].fRowBytes,
+                                           rect.height() * texels[i].fRowBytes);
+    }
+
+    return true;
+}
+
+bool GrD3D11Gpu::onTransferFromBufferToBuffer(sk_sp<GrGpuBuffer> src,
+                                            size_t srcOffset,
+                                            sk_sp<GrGpuBuffer> dst,
+                                            size_t dstOffset,
+                                            size_t size) {
+
+    sk_sp<GrD3D11Buffer> d3d11Src(static_cast<GrD3D11Buffer*>(src.release()));
+    sk_sp<GrD3D11Buffer> d3d11Dst(static_cast<GrD3D11Buffer*>(dst.release()));
+
+    D3D11_BUFFER_DESC srcDesc, dstDesc;
+    d3d11Src->d3d11Resource()->GetDesc(&srcDesc);
+    d3d11Dst->d3d11Resource()->GetDesc(&dstDesc);
+
+    uint64_t dstSize = dstDesc.ByteWidth;
+    uint64_t srcSize = srcDesc.ByteWidth;
+
+    if (dstSize == srcSize && srcSize == size)
+        deviceContext()->CopyResource(d3d11Dst->d3d11Resource(), d3d11Src->d3d11Resource());
+    else {
+        D3D11_BOX srcBox;
+        srcBox.left = srcOffset;
+        srcBox.right = srcOffset + size;
+        srcBox.top = 0;
+        srcBox.bottom = 1;
+        srcBox.front = 0;
+        srcBox.back = 1;
+        deviceContext()->CopySubresourceRegion(d3d11Dst->d3d11Resource(),
+                                               0,
+                                               dstOffset,
+                                               0,
+                                               0,
+                                               d3d11Src->d3d11Resource(),
+                                               0,
+                                               &srcBox);
+    }
+
+    return true;
+}
+
+bool GrD3D11Gpu::onTransferPixelsTo(GrTexture* texture,
+                                  SkIRect rect,
+                                  GrColorType surfaceColorType,
+                                  GrColorType bufferColorType,
+                                  sk_sp<GrGpuBuffer> transferBuffer,
+                                  size_t bufferOffset,
+                                  size_t rowBytes) {
+    if (!transferBuffer) {
+        return false;
+    }
+
+    size_t bpp = GrColorTypeBytesPerPixel(bufferColorType);
+    if (GrBackendFormatBytesPerPixel(texture->backendFormat()) != bpp) {
+        return false;
+    }
+
+    // D3D requires offsets for texture transfers to be aligned to this value
+    if (SkToBool(bufferOffset & (512 - 1))) { //D3D12_TEXTURE_DATA_PLACEMENT_ALIGNMENT
+        return false;
+    }
+
+    GrD3D11Texture* d3d11Tex = static_cast<GrD3D11Texture*>(texture);
+    if (!d3d11Tex) {
+        return false;
+    }
+
+    SkDEBUGCODE(DXGI_FORMAT format = d3d11Tex->dxgiFormat());
+
+    // Can't transfer compressed data
+    SkASSERT(!GrDxgiFormatIsCompressed(format));
+
+    SkASSERT(GrDxgiFormatBytesPerBlock(format) == GrColorTypeBytesPerPixel(bufferColorType));
+
+    SkASSERT(SkIRect::MakeSize(texture->dimensions()).contains(rect));
+
+    // Set up copy region
+    ID3D11Buffer* d3d11Buffer = static_cast<GrD3D11Buffer*>(transferBuffer.get())->d3d11Resource();
+    deviceContext()->CopySubresourceRegion(
+            d3d11Tex->d3d11Resource(), 0, rect.left(), rect.top(), 0, d3d11Buffer, 0, nullptr);
+
+    d3d11Tex->markMipmapsDirty();
+    return true;
+}
+
+bool GrD3D11Gpu::onTransferPixelsFrom(GrSurface* surface,
+                                    SkIRect rect,
+                                    GrColorType surfaceColorType,
+                                    GrColorType bufferColorType,
+                                    sk_sp<GrGpuBuffer> transferBuffer,
+                                    size_t offset) {
+    SkASSERT(surface);
+    SkASSERT(transferBuffer);
+    // TODO
+    // if (fProtectedContext == GrProtected::kYes) {
+    //    return false;
+    //}
+
+    // D3D requires offsets for texture transfers to be aligned to this value
+    if (SkToBool(offset & (512 - 1))) { //D3D12_TEXTURE_DATA_PLACEMENT_ALIGNMENT
+        return false;
+    }
+
+    ID3D11Texture2D* texResource = nullptr;
+    SkDEBUGCODE(DXGI_FORMAT format);
+    GrD3D11RenderTarget* rt = static_cast<GrD3D11RenderTarget*>(surface->asRenderTarget());
+    if (rt) {
+        texResource = rt->d3d11Resource();
+        SkDEBUGCODE(format = rt->dxgiFormat());
+    } else {
+        texResource = static_cast<GrD3D11Texture*>(surface->asTexture())->d3d11Resource();
+        SkDEBUGCODE(format = static_cast<GrD3D11Texture*>(surface->asTexture())->dxgiFormat());
+    }
+
+    if (!texResource) {
+        return false;
+    }
+
+    SkASSERT(GrDxgiFormatBytesPerBlock(format) == GrColorTypeBytesPerPixel(bufferColorType));
+
+    D3D11_BOX srcBox = {};
+    srcBox.left = rect.left();
+    srcBox.top = rect.top();
+    srcBox.right = rect.right();
+    srcBox.bottom = rect.bottom();
+    srcBox.front = 0;
+    srcBox.back = 1;
+    ID3D11Buffer* d3d11Buffer = static_cast<GrD3D11Buffer*>(transferBuffer.get())->d3d11Resource();
+    deviceContext()->CopySubresourceRegion(d3d11Buffer, 0, 0, 0, 0, texResource, 0, &srcBox);
+
+    return true;
+}
+
+static bool check_resource_info(const GrD3D11TextureInfo& info) {
+    if (!info.fTexture.get()) {
+        return false;
+    }
+    return true;
+}
+
+static bool check_tex_resource_info(const GrD3D11Caps& caps, const GrD3D11TextureInfo& info) {
+    if (!caps.isFormatTexturable(info.fFormat)) {
+        return false;
+    }
+    // We don't support sampling from multisampled textures.
+    if (info.fSampleCount != 1) {
+        return false;
+    }
+    return true;
+}
+
+static bool check_rt_resource_info(const GrD3D11Caps& caps,
+                                   const GrD3D11TextureInfo& info,
+                                   int sampleCnt) {
+    if (!caps.isFormatRenderable(info.fFormat, sampleCnt)) {
+        return false;
+    }
+    return true;
+}
+
+sk_sp<GrTexture> GrD3D11Gpu::onWrapBackendTexture(const GrBackendTexture& tex,
+                                                 GrWrapOwnership ownership,
+                                                 GrWrapCacheable wrapType,
+                                                 GrIOType ioType) {
+    auto textureInfo = GrD3D11TextureInfo::getInfo(tex);
+
+    if (!check_resource_info(textureInfo)) {
+        return nullptr;
+    }
+
+    if (!check_tex_resource_info(this->d3d11Caps(), textureInfo)) {
+        return nullptr;
+    }
+
+    // TODO: support protected context
+    if (tex.isProtected()) {
+        return nullptr;
+    }
+
+    return GrD3D11Texture::MakeWrappedTexture(
+            this, tex.dimensions(), wrapType, ioType, textureInfo);
+}
+
+sk_sp<GrTexture> GrD3D11Gpu::onWrapCompressedBackendTexture(const GrBackendTexture& tex,
+                                                           GrWrapOwnership ownership,
+                                                           GrWrapCacheable wrapType) {
+    return this->onWrapBackendTexture(tex, ownership, wrapType, kRead_GrIOType);
+}
+
+sk_sp<GrTexture> GrD3D11Gpu::onWrapRenderableBackendTexture(const GrBackendTexture& tex,
+                                                           int sampleCnt,
+                                                           GrWrapOwnership ownership,
+                                                           GrWrapCacheable cacheable) {
+    auto textureInfo = GrD3D11TextureInfo::getInfo(tex);
+
+    if (!check_resource_info(textureInfo)) {
+        return nullptr;
+    }
+
+    if (!check_tex_resource_info(this->d3d11Caps(), textureInfo)) {
+        return nullptr;
+    }
+    if (!check_rt_resource_info(this->d3d11Caps(), textureInfo, sampleCnt)) {
+        return nullptr;
+    }
+
+    // TODO: support protected context
+    if (tex.isProtected()) {
+        return nullptr;
+    }
+
+    sampleCnt = this->d3d11Caps().getRenderTargetSampleCount(sampleCnt, textureInfo.fFormat);
+
+    return GrD3D11TextureRenderTarget::MakeWrappedTextureRenderTarget(
+            this, tex.dimensions(), sampleCnt, cacheable, textureInfo);
+}
+
+sk_sp<GrRenderTarget> GrD3D11Gpu::onWrapBackendRenderTarget(const GrBackendRenderTarget& rt) {
+    auto textureInfo = GrD3D11TextureInfo::getInfo(rt);
+
+    if (!check_resource_info(textureInfo)) {
+        return nullptr;
+    }
+
+    if (!check_rt_resource_info(this->d3d11Caps(), textureInfo, rt.sampleCnt())) {
+        return nullptr;
+    }
+
+    // TODO: support protected context
+    if (rt.isProtected()) {
+        return nullptr;
+    }
+
+    sk_sp<GrD3D11RenderTarget> tgt = GrD3D11RenderTarget::MakeWrappedRenderTarget(
+            this, rt.dimensions(), rt.sampleCnt(), textureInfo);
+
+    // We don't allow the client to supply a premade stencil buffer. We always create one if needed.
+    SkASSERT(!rt.stencilBits());
+    if (tgt) {
+        SkASSERT(tgt->canAttemptStencilAttachment(tgt->numSamples() > 1));
+    }
+
+    return std::move(tgt);
+}
+
+bool GrD3D11Gpu::onRegenerateMipMapLevels(GrTexture* tex) {
+    auto* d3d11Tex = static_cast<GrD3D11Texture*>(tex);
+    SkASSERT(tex->textureType() == GrTextureType::k2D);
+
+    // determine if we can read from and mipmap this format
+    const GrD3D11Caps& caps = this->d3d11Caps();
+    if (!caps.isFormatTexturable(d3d11Tex->dxgiFormat()) || !caps.mipmapSupport()) {
+        return false;
+    }
+
+    deviceContext()->GenerateMips(d3d11Tex->shaderResourceView());
+    return true;
+}
+
+sk_sp<GrGpuBuffer> GrD3D11Gpu::onCreateBuffer(size_t sizeInBytes,
+                                             GrGpuBufferType type,
+                                             GrAccessPattern accessPattern) {
+    return GrD3D11Buffer::Make(this, sizeInBytes, type, accessPattern);
+}
+
+sk_sp<GrAttachment> GrD3D11Gpu::makeStencilAttachment(const GrBackendFormat& /*colorFormat*/,
+                                                     SkISize dimensions, int numStencilSamples) {
+    DXGI_FORMAT sFmt = this->d3d11Caps().preferredStencilFormat();
+
+    fStats.incStencilAttachmentCreates();
+    return GrD3D11Attachment::MakeStencil(this, dimensions, numStencilSamples, sFmt);
+}
+
+bool GrD3D11Gpu::createTextureResourceForBackendSurface(DXGI_FORMAT dxgiFormat,
+                                                      SkISize dimensions,
+                                                      GrTexturable texturable,
+                                                      GrRenderable renderable,
+                                                      skgpu::Mipmapped mipmapped,
+                                                      int sampleCnt,
+                                                      GrD3D11TextureInfo* info,
+                                                      GrProtected isProtected) {
+    SkASSERT(texturable == GrTexturable::kYes || renderable == GrRenderable::kYes);
+
+    D3D11_USAGE usage = D3D11_USAGE_DEFAULT;
+    UINT bindFlags = D3D11_BIND_SHADER_RESOURCE;
+    UINT cpuFlags = 0;
+    UINT miscFlags = 0;
+
+    if (this->protectedContext() != (isProtected == GrProtected::kYes)) {
+        return false;
+    }
+
+    if (texturable == GrTexturable::kYes && !this->d3d11Caps().isFormatTexturable(dxgiFormat)) {
+        return false;
+    }
+
+    if (renderable == GrRenderable::kYes) {
+        if (!this->d3d11Caps().isFormatRenderable(dxgiFormat, 1)) {
+            return false;
+        }
+
+        bindFlags |= D3D11_BIND_RENDER_TARGET;
+    }
+
+    int numMipLevels = 1;
+    if (mipmapped == skgpu::Mipmapped::kYes) {
+        numMipLevels = SkMipmap::ComputeLevelCount(dimensions.width(), dimensions.height()) + 1;
+        miscFlags |= D3D11_RESOURCE_MISC_GENERATE_MIPS;
+        bindFlags |= D3D11_BIND_RENDER_TARGET;
+    }
+
+    if (renderable == GrRenderable::kYes) {
+        bindFlags |= D3D11_BIND_RENDER_TARGET;
+    }
+
+    D3D11_TEXTURE2D_DESC resourceDesc = {};
+    resourceDesc.Width = dimensions.fWidth;
+    resourceDesc.Height = dimensions.fHeight;
+    resourceDesc.MipLevels = numMipLevels;
+    resourceDesc.Format = dxgiFormat;
+    resourceDesc.SampleDesc.Count = 1;
+    resourceDesc.SampleDesc.Quality = 0;
+    resourceDesc.Usage = usage;
+    resourceDesc.BindFlags = bindFlags;
+    resourceDesc.CPUAccessFlags = cpuFlags;
+    resourceDesc.MiscFlags = miscFlags;
+    resourceDesc.ArraySize = 1;
+
+    info->fFormat = dxgiFormat;
+    HRESULT hr = device()->CreateTexture2D(&resourceDesc, nullptr, &info->fTexture);
+    GR_D3D_CALL_ERRCHECK(hr);
+
+    info->fLevelCount = numMipLevels;
+    info->fProtected = isProtected;
+    info->fSampleCount = sampleCnt;
+
+    return true;
+}
+
+GrBackendTexture GrD3D11Gpu::onCreateBackendTexture(SkISize dimensions,
+                                                  const GrBackendFormat& format,
+                                                  GrRenderable renderable,
+                                                  skgpu::Mipmapped mipmapped,
+                                                  GrProtected isProtected,
+                                                  std::string_view label) {
+    const GrD3D11Caps& caps = this->d3d11Caps();
+
+    if (this->protectedContext() != (isProtected == GrProtected::kYes)) {
+        return {};
+    }
+
+    DXGI_FORMAT dxgiFormat;
+    if (!format.asDxgiFormat(&dxgiFormat)) {
+        return {};
+    }
+
+    // TODO: move the texturability check up to GrGpu::createBackendTexture and just assert here
+    if (!caps.isFormatTexturable(dxgiFormat)) {
+        return {};
+    }
+
+    GrD3D11TextureInfo info;
+    if (!this->createTextureResourceForBackendSurface(dxgiFormat,
+                                                      dimensions,
+                                                      GrTexturable::kYes,
+                                                      renderable,
+                                                      mipmapped,
+                                                      1,
+                                                      &info,
+                                                      isProtected)) {
+        return {};
+    }
+
+    return GrBackendTexture(dimensions.width(), dimensions.height(), info.toD3D12Info());
+}
+
+bool GrD3D11Gpu::onClearBackendTexture(const GrBackendTexture& backendTexture,
+                                     sk_sp<skgpu::RefCntedCallback> finishedCallback,
+                                     std::array<float, 4> color) {
+    auto textureInfo = GrD3D11TextureInfo::getInfo(backendTexture);
+
+
+    SkASSERT(!GrDxgiFormatIsCompressed(textureInfo.fFormat));
+    
+    backendTexture.dimensions();
+
+    sk_sp<GrD3D11RenderTarget> renderTarget = GrD3D11RenderTarget::MakeWrappedRenderTarget(
+            this, backendTexture.dimensions(), textureInfo.fSampleCount, textureInfo);
+
+    deviceContext()->ClearRenderTargetView(renderTarget->colorRenderTargetView(), color.data());
+    return true;
+}
+
+GrBackendTexture GrD3D11Gpu::onCreateCompressedBackendTexture(SkISize dimensions,
+                                                            const GrBackendFormat& format,
+                                                            skgpu::Mipmapped mipmapped,
+                                                            GrProtected isProtected) {
+    return this->onCreateBackendTexture(dimensions,
+                                        format,
+                                        GrRenderable::kNo,
+                                        mipmapped,
+                                        isProtected,
+                                        /*label=*/"D3DGpu_CreateCompressedBackendTexture");
+
+}
+
+bool GrD3D11Gpu::onUpdateCompressedBackendTexture(const GrBackendTexture& backendTexture,
+                                                sk_sp<skgpu::RefCntedCallback> finishedCallback,
+                                                const void* data,
+                                                size_t size) {
+    auto textureInfo = GrD3D11TextureInfo::getInfo(backendTexture);
+
+    SkISize dimensions = backendTexture.dimensions();
+
+    ID3D11Texture2D* d3d11Resource = textureInfo.fTexture.get();
+    SkASSERT(d3d11Resource);
+    D3D11_TEXTURE2D_DESC desc;
+    d3d11Resource->GetDesc(&desc);
+
+    unsigned int mipLevelCount = 1;
+    if (backendTexture.hasMipmaps()) {
+        mipLevelCount = SkMipmap::ComputeLevelCount(dimensions.width(),
+                                                    dimensions.height()) +
+                        1;
+    }
+
+    SkIRect rect;
+    rect.setXYWH(0, 0, dimensions.width(), dimensions.height());
+
+    SkTextureCompressionType compressionType = GrBackendFormatToCompressionType(backendTexture.getBackendFormat());
+    SkASSERT(size == SkCompressedFormatDataSize(compressionType,
+                                                dimensions,
+                                                backendTexture.mipmapped() == skgpu::Mipmapped::kYes));
+
+    GrMipLevel mipLevels[32];
+
+    const char* ptr = (const char*)data;
+    for (unsigned int i = 0; i < mipLevelCount; ++i) {
+        size_t levelDataSize =
+                SkCompressedDataSize(compressionType, dimensions, nullptr, false);
+
+        mipLevels[i].fPixels = ptr;
+        mipLevels[i].fRowBytes = levelDataSize / dimensions.height();
+        ptr += levelDataSize;
+        dimensions = {std::max(1, dimensions.width() / 2), std::max(1, dimensions.height() / 2)};
+    }
+
+    return uploadToTexture(d3d11Resource, rect, mipLevels, mipLevelCount);
+}
+
+void GrD3D11Gpu::deleteBackendTexture(const GrBackendTexture& tex) {
+    SkASSERT(GrBackendApi::kDirect3D == tex.backend());
+    // Nothing to do here, will get cleaned up when the GrBackendTexture object goes away
+}
+
+bool GrD3D11Gpu::compile(const GrProgramDesc&, const GrProgramInfo&) { 
+    return false; 
+}
+
+#if defined(GPU_TEST_UTILS)
+bool GrD3D11Gpu::isTestingOnlyBackendTexture(const GrBackendTexture& tex) const {
+    SkASSERT(GrBackendApi::kDirect3D == tex.backend());
+
+    auto textureInfo = GrD3D11TextureInfo::getInfo(tex);
+    ID3D11Texture2D* d3d11Tex = textureInfo.fTexture.get();
+    if (!d3d11Tex) 
+        return false;
+
+    D3D11_TEXTURE2D_DESC desc;
+    d3d11Tex->GetDesc(&desc);
+    return true;
+}
+
+GrBackendRenderTarget GrD3D11Gpu::createTestingOnlyBackendRenderTarget(SkISize dimensions,
+                                                                      GrColorType colorType,
+                                                                      int sampleCnt,
+                                                                       GrProtected isProtected) {
+    if (dimensions.width() > this->caps()->maxRenderTargetSize() ||
+        dimensions.height() > this->caps()->maxRenderTargetSize()) {
+        return {};
+    }
+
+    DXGI_FORMAT dxgiFormat = this->d3d11Caps().getFormatFromColorType(colorType);
+
+    GrD3D11TextureInfo info;
+    if (!this->createTextureResourceForBackendSurface(dxgiFormat,
+                                                      dimensions,
+                                                      GrTexturable::kNo,
+                                                      GrRenderable::kYes,
+                                                      skgpu::Mipmapped::kNo,
+                                                      sampleCnt,
+                                                      &info,
+                                                      isProtected)) {
+        return {};
+    }
+
+    return GrBackendRenderTarget(dimensions.width(), dimensions.height(), info.toD3D12Info());
+}
+
+void GrD3D11Gpu::deleteTestingOnlyBackendRenderTarget(const GrBackendRenderTarget& rt) {
+    SkASSERT(GrBackendApi::kDirect3D == rt.backend());
+
+    auto textureInfo = GrD3D11TextureInfo::getInfo(rt);
+    if (textureInfo.fTexture.get()) {
+        GrSubmitInfo submitInfo;
+        submitInfo.fSync = GrSyncCpu::kYes;
+        
+        this->submitToGpu(submitInfo);
+        // Nothing else to do here, will get cleaned up when the GrBackendRenderTarget
+        // is deleted.
+    }
+}
+
+void GrD3D11Gpu::testingOnly_startCapture() {
+    if (fGraphicsAnalysis) {
+        fGraphicsAnalysis->BeginCapture();
+    }
+}
+
+void GrD3D11Gpu::testingOnly_stopCapture() {
+    if (fGraphicsAnalysis) {
+        fGraphicsAnalysis->EndCapture();
+    }
+}
+
+#endif
diff --git a/src/gpu/ganesh/d3d11/GrD3D11Gpu.h b/src/gpu/ganesh/d3d11/GrD3D11Gpu.h
new file mode 100644
index 0000000000..53d843a79b
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11Gpu.h
@@ -0,0 +1,297 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef GrD3D11Gpu_DEFINED
+#define GrD3D11Gpu_DEFINED
+
+#include "src/gpu/ganesh/GrGpu.h"
+#include "src/gpu/ganesh/GrRenderTarget.h"
+#include "src/gpu/ganesh/GrSemaphore.h"
+#include "src/gpu/ganesh/GrTexture.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Caps.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11ResourceProvider.h"
+
+#include "src/gpu/ganesh/d3d/GrD3DGpu.h"
+
+class GrD3D11OpsRenderPass;
+struct GrD3D11Options;
+class GrPipeline;
+class GrD3D11Texture;
+
+#if GR_TEST_UTILS
+struct IDXGraphicsAnalysis;
+#endif
+
+class GrD3D11Gpu : public GrGpu {
+public:
+    static std::unique_ptr<GrGpu> Make(GrDirectContext*, const GrContextOptions&, const GrD3DBackendContext&);
+
+    virtual ~GrD3D11Gpu() override;
+
+    const GrD3D11Caps& d3d11Caps() const { return static_cast<const GrD3D11Caps&>(*this->caps()); }
+
+    GrD3D11ResourceProvider& resourceProvider() { return fResourceProvider; }
+
+    GrThreadSafePipelineBuilder* pipelineBuilder() override;
+    sk_sp<GrThreadSafePipelineBuilder> refPipelineBuilder() override;
+
+    ID3D11Device* device() const { return fDevice.get(); }
+    ID3D11DeviceContext* deviceContext() const { return fDeviceContext.get(); }
+
+    bool protectedContext() const { return false; }
+
+    void xferBarrier(GrRenderTarget*, GrXferBarrierType) override {}
+
+    void deleteBackendTexture(const GrBackendTexture&) override;
+
+    bool compile(const GrProgramDesc&, const GrProgramInfo&) override;
+
+#if defined(GPU_TEST_UTILS)
+    bool isTestingOnlyBackendTexture(const GrBackendTexture&) const override;
+
+    GrBackendRenderTarget createTestingOnlyBackendRenderTarget(SkISize dimensions,
+                                                               GrColorType,
+                                                               int sampleCnt,
+                                                               GrProtected) override;
+    void deleteTestingOnlyBackendRenderTarget(const GrBackendRenderTarget&) override;
+
+    void testingOnly_startCapture() override;
+    void testingOnly_stopCapture() override;
+
+    void resetShaderCacheForTesting() const override {
+        fResourceProvider.resetShaderCacheForTesting();
+    }
+#endif
+
+    sk_sp<GrAttachment> makeStencilAttachment(const GrBackendFormat& /*colorFormat*/,
+                                              SkISize dimensions,
+                                              int numStencilSamples) override;
+
+    GrBackendFormat getPreferredStencilFormat(const GrBackendFormat&) override {
+        return GrBackendFormat::MakeDxgi(this->d3d11Caps().preferredStencilFormat());
+    }
+
+    sk_sp<GrAttachment> makeMSAAAttachment(SkISize dimensions,
+                                           const GrBackendFormat& format,
+                                           int numSamples,
+                                           GrProtected isProtected,
+                                           GrMemoryless isMemoryless) override {
+        return nullptr;
+    }
+
+    [[nodiscard]] std::unique_ptr<GrSemaphore> makeSemaphore(bool isOwned) override {
+        return nullptr;
+    }
+    std::unique_ptr<GrSemaphore> wrapBackendSemaphore(const GrBackendSemaphore& /* semaphore */,
+                                                      GrSemaphoreWrapType /* wraptype */,
+                                                      GrWrapOwnership /* ownership */) override {
+        return nullptr;
+    }
+    void insertSemaphore(GrSemaphore* semaphore) override {}
+    void waitSemaphore(GrSemaphore* semaphore) override {}
+    std::unique_ptr<GrSemaphore> prepareTextureForCrossContextUsage(GrTexture*) override {
+        return nullptr;
+    }
+
+    void submit(GrOpsRenderPass* renderPass) override;
+    void endRenderPass(GrRenderTarget* target, GrSurfaceOrigin origin, const SkIRect& bounds);
+
+    void checkFinishProcs() override {}
+    void finishOutstandingGpuWork() override {}
+
+private:
+    GrD3D11Gpu(GrDirectContext*, const GrContextOptions&, const GrD3DBackendContext&);
+
+    void destroyResources();
+
+    sk_sp<GrTexture> onCreateTexture(SkISize,
+                                     const GrBackendFormat&,
+                                     GrRenderable,
+                                     int renderTargetSampleCnt,
+                                     skgpu::Budgeted,
+                                     GrProtected,
+                                     int mipLevelCount,
+                                     uint32_t levelClearMask,
+                                     std::string_view label) override;
+
+    sk_sp<GrTexture> onCreateCompressedTexture(SkISize dimensions,
+                                               const GrBackendFormat&,
+                                               skgpu::Budgeted,
+                                               skgpu::Mipmapped,
+                                               GrProtected,
+                                               const void* data, size_t dataSize) override;
+
+    sk_sp<GrTexture> onWrapBackendTexture(const GrBackendTexture&,
+                                          GrWrapOwnership,
+                                          GrWrapCacheable,
+                                          GrIOType) override;
+    sk_sp<GrTexture> onWrapCompressedBackendTexture(const GrBackendTexture&,
+                                                    GrWrapOwnership,
+                                                    GrWrapCacheable) override;
+
+    sk_sp<GrTexture> onWrapRenderableBackendTexture(const GrBackendTexture&,
+                                                    int sampleCnt,
+                                                    GrWrapOwnership,
+                                                    GrWrapCacheable) override;
+
+    sk_sp<GrRenderTarget> onWrapBackendRenderTarget(const GrBackendRenderTarget&) override;
+
+    sk_sp<GrGpuBuffer> onCreateBuffer(size_t sizeInBytes,
+                                      GrGpuBufferType,
+                                      GrAccessPattern) override;
+
+    bool onReadPixels(GrSurface*,
+                      SkIRect,
+                      GrColorType surfaceColorType,
+                      GrColorType dstColorType,
+                      void*,
+                      size_t rowBytes) override;
+
+    bool onWritePixels(GrSurface*,
+                       SkIRect,
+                       GrColorType surfaceColorType,
+                       GrColorType srcColorType,
+                       const GrMipLevel[],
+                       int mipLevelCount,
+                       bool prepForTexSampling) override;
+
+    bool onTransferFromBufferToBuffer(sk_sp<GrGpuBuffer> src,
+                                      size_t srcOffset,
+                                      sk_sp<GrGpuBuffer> dst,
+                                      size_t dstOffset,
+                                      size_t size) override;
+
+    bool onTransferPixelsTo(GrTexture*,
+                            SkIRect,
+                            GrColorType surfaceColorType,
+                            GrColorType bufferColorType,
+                            sk_sp<GrGpuBuffer>,
+                            size_t offset,
+                            size_t rowBytes) override;
+
+    bool onTransferPixelsFrom(GrSurface*,
+                              SkIRect,
+                              GrColorType surfaceColorType,
+                              GrColorType bufferColorType,
+                              sk_sp<GrGpuBuffer>,
+                              size_t offset) override;
+
+    bool onCopySurface(GrSurface* dst,
+                       const SkIRect& dstRect,
+                       GrSurface* src,
+                       const SkIRect& srcRect,
+                       GrSamplerState::Filter) override;
+
+    bool onRegenerateMipMapLevels(GrTexture*) override;
+
+    void onResolveRenderTarget(GrRenderTarget* target, const SkIRect&) override;
+
+    void addFinishedProc(GrGpuFinishedProc finishedProc,
+                         GrGpuFinishedContext finishedContext) override;
+
+    GrOpsRenderPass* onGetOpsRenderPass(GrRenderTarget*,
+                                        bool useMSAASurface,
+                                        GrAttachment*,
+                                        GrSurfaceOrigin,
+                                        const SkIRect&,
+                                        const GrOpsRenderPass::LoadAndStoreInfo&,
+                                        const GrOpsRenderPass::StencilLoadAndStoreInfo&,
+                                        const skia_private::TArray<GrSurfaceProxy*, true>& sampledProxies,
+                                        GrXferBarrierFlags renderPassXferBarriers) override;
+
+   void prepareSurfacesForBackendAccessAndStateUpdates(
+            SkSpan<GrSurfaceProxy*> proxies,
+            SkSurfaces::BackendSurfaceAccess access,
+            const skgpu::MutableTextureState* newState) override {}
+
+    bool onSubmitToGpu(const GrSubmitInfo& info) override {
+        return true;
+    }
+
+    GrBackendTexture onCreateBackendTexture(SkISize dimensions,
+                                            const GrBackendFormat&,
+                                            GrRenderable,
+                                            skgpu::Mipmapped,
+                                            GrProtected,
+                                            std::string_view label) override;
+
+    bool onClearBackendTexture(const GrBackendTexture&,
+                               sk_sp<skgpu::RefCntedCallback> finishedCallback,
+                               std::array<float, 4> color) override;
+
+    GrBackendTexture onCreateCompressedBackendTexture(SkISize dimensions,
+                                                      const GrBackendFormat&,
+                                                      skgpu::Mipmapped,
+                                                      GrProtected) override;
+
+    bool onUpdateCompressedBackendTexture(const GrBackendTexture&,
+                                          sk_sp<skgpu::RefCntedCallback> finishedCallback,
+                                          const void*,
+                                          size_t) override;
+
+    void copySurfaceAsCopyTexture(GrSurface* dst,
+                                  GrSurface* src,
+                                  ID3D11Texture2D* dstResource,
+                                  ID3D11Texture2D* srcResource,
+                                  const SkIRect& srcRect,
+                                  const SkIPoint& dstPoint);
+
+    void copySurfaceAsResolve(GrSurface* dst,
+                              GrSurface* src,
+                              const SkIRect& srcRect,
+                              const SkIPoint& dstPoint);
+    void resolveTexture(GrSurface* dst,
+                        int32_t dstX,
+                        int32_t dstY,
+                        GrD3D11RenderTarget* src,
+                        const SkIRect& srcRect);
+
+    sk_sp<GrD3D11Texture> createD3D11Texture(SkISize,
+                                         DXGI_FORMAT,
+                                         GrRenderable,
+                                         int renderTargetSampleCnt,
+                                         skgpu::Budgeted,
+                                         GrProtected,
+                                         int mipLevelCount,
+                                         GrMipmapStatus,
+                                         std::string_view label);
+
+    bool uploadToTexture(GrD3D11Texture* tex,
+                         SkIRect rect,
+                         const GrMipLevel texels[],
+                         int mipLevelCount);
+
+    bool uploadToTexture(ID3D11Texture2D* tex,
+                         SkIRect rect,
+                         const GrMipLevel texels[],
+                         int mipLevelCount);
+
+
+    bool createTextureResourceForBackendSurface(DXGI_FORMAT dxgiFormat,
+                                                SkISize dimensions,
+                                                GrTexturable texturable,
+                                                GrRenderable renderable,
+                                                skgpu::Mipmapped mipmapped,
+                                                int sampleCnt,
+                                                GrD3D11TextureInfo* info,
+                                                GrProtected isProtected);
+
+    gr_cp<ID3D11Device> fDevice;
+    gr_cp<ID3D11DeviceContext> fDeviceContext;
+    
+    GrD3D11ResourceProvider fResourceProvider;
+
+    std::unique_ptr<GrD3D11OpsRenderPass> fCachedOpsRenderPass;
+
+#if defined(GPU_TEST_UTILS)
+    IDXGraphicsAnalysis* fGraphicsAnalysis;
+#endif
+
+    using INHERITED = GrGpu;
+};
+
+#endif
diff --git a/src/gpu/ganesh/d3d11/GrD3D11OpTarget.h b/src/gpu/ganesh/d3d11/GrD3D11OpTarget.h
new file mode 100644
index 0000000000..d545b73b18
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11OpTarget.h
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef GrD3D11OpTarget_DEFINED
+#define GrD3D11OpTarget_DEFINED
+
+#include "include/gpu/GrDirectContext.h"
+#include "src/gpu/ganesh/GrAppliedClip.h"
+#include "src/gpu/ganesh/GrDirectContextPriv.h"
+#include "src/gpu/ganesh/GrDstProxyView.h"
+#include "src/gpu/ganesh/GrGpu.h"
+#include "src/gpu/ganesh/GrMeshDrawTarget.h"
+
+// This is a d3d11 GrMeshDrawTarget implementation that just gives back pointers into
+// pre-allocated CPU buffers, rather than allocating and mapping GPU buffers.
+class GrD3D11OpTarget : public GrMeshDrawTarget {
+public:
+    GrD3D11OpTarget(sk_sp<GrDirectContext> d3d11Context) : fD3D11Context(std::move(d3d11Context)) {
+        fStaticVertexBuffer = fD3D11Context->priv().getGpu()->createBuffer(
+                sizeof(fStaticVertexData), GrGpuBufferType::kVertex, kDynamic_GrAccessPattern);
+        fStaticIndirectBuffer = fD3D11Context->priv().getGpu()->createBuffer(
+                sizeof(fStaticIndirectData), GrGpuBufferType::kDrawIndirect,
+                kDynamic_GrAccessPattern);
+    }
+    const GrDirectContext* d3d11Context() const { return fD3D11Context.get(); }
+    const GrCaps& caps() const override { return *fD3D11Context->priv().caps(); }
+    GrThreadSafeCache* threadSafeCache() const override {
+        return fD3D11Context->priv().threadSafeCache();
+    }
+    GrResourceProvider* resourceProvider() const override {
+        return fD3D11Context->priv().resourceProvider();
+    }
+#ifndef SK_ENABLE_OPTIMIZE_SIZE
+    skgpu::v1::SmallPathAtlasMgr* smallPathAtlasManager() const override { return nullptr; }
+#endif
+    void resetAllocator() { fAllocator.reset(); }
+    SkArenaAlloc* allocator() override { return &fAllocator; }
+    void putBackVertices(int vertices, size_t vertexStride) override { /* no-op */ }
+    GrAppliedClip detachAppliedClip() override { return GrAppliedClip::Disabled(); }
+    const GrDstProxyView& dstProxyView() const override { return fDstProxyView; }
+    GrXferBarrierFlags renderPassBarriers() const override { return GrXferBarrierFlags::kNone; }
+    GrLoadOp colorLoadOp() const override { return GrLoadOp::kLoad; }
+
+    void* makeVertexSpace(size_t vertexSize, int vertexCount, sk_sp<const GrBuffer>* buffer,
+                          int* startVertex) override {
+        if (vertexSize * vertexCount > sizeof(fStaticVertexData)) {
+            SK_ABORT("FATAL: wanted %zu bytes of static vertex data; only have %zu.\n",
+                     vertexSize * vertexCount, sizeof(fStaticVertexData));
+        }
+        *buffer = fStaticVertexBuffer;
+        *startVertex = 0;
+        return fStaticVertexData;
+    }
+
+    void* makeVertexSpaceAtLeast(size_t vertexSize, int minVertexCount, int fallbackVertexCount,
+                                 sk_sp<const GrBuffer>* buffer, int* startVertex,
+                                 int* actualVertexCount) override {
+        if (vertexSize * minVertexCount > sizeof(fStaticVertexData)) {
+            SK_ABORT("FATAL: wanted %zu bytes of static vertex data; only have %zu.\n",
+                     vertexSize * minVertexCount, sizeof(fStaticVertexData));
+        }
+        *buffer = fStaticVertexBuffer;
+        *startVertex = 0;
+        *actualVertexCount = sizeof(fStaticVertexData) / vertexSize;
+        return fStaticVertexData;
+    }
+
+    GrDrawIndirectWriter makeDrawIndirectSpace(int drawCount, sk_sp<const GrBuffer>* buffer,
+                                               size_t* offsetInBytes) override {
+        if (sizeof(GrDrawIndirectCommand) * drawCount > sizeof(fStaticIndirectData)) {
+            SK_ABORT("FATAL: wanted %zu bytes of static indirect data; only have %zu.\n",
+                     sizeof(GrDrawIndirectCommand) * drawCount, sizeof(fStaticIndirectData));
+        }
+        *buffer = fStaticIndirectBuffer;
+        *offsetInBytes = 0;
+        return fStaticIndirectData;
+    }
+
+    void putBackIndirectDraws(int count) override { /* no-op */ }
+
+    GrDrawIndexedIndirectWriter makeDrawIndexedIndirectSpace(int drawCount,
+                                                             sk_sp<const GrBuffer>* buffer,
+                                                             size_t* offsetInBytes) override {
+        if (sizeof(GrDrawIndexedIndirectCommand) * drawCount > sizeof(fStaticIndirectData)) {
+            SK_ABORT("FATAL: wanted %zu bytes of static indirect data; only have %zu.\n",
+                     sizeof(GrDrawIndexedIndirectCommand) * drawCount, sizeof(fStaticIndirectData));
+        }
+        *buffer = fStaticIndirectBuffer;
+        *offsetInBytes = 0;
+        return fStaticIndirectData;
+    }
+
+    void putBackIndexedIndirectDraws(int count) override { /* no-op */ }
+
+    // Call these methods to see what got written after the previous call to make*Space.
+    const void* peekStaticVertexData() const { return fStaticVertexData; }
+    const void* peekStaticIndirectData() const { return fStaticIndirectData; }
+
+#define UNIMPL(...) __VA_ARGS__ override { SK_ABORT("unimplemented."); }
+    UNIMPL(void recordDraw(const GrGeometryProcessor*, const GrSimpleMesh[], int,
+                           const GrSurfaceProxy* const[], GrPrimitiveType))
+    UNIMPL(uint16_t* makeIndexSpace(int, sk_sp<const GrBuffer>*, int*))
+    UNIMPL(uint16_t* makeIndexSpaceAtLeast(int, int, sk_sp<const GrBuffer>*, int*, int*))
+    UNIMPL(void putBackIndices(int))
+    UNIMPL(GrRenderTargetProxy* rtProxy() const)
+    UNIMPL(const GrSurfaceProxyView& writeView() const)
+    UNIMPL(const GrAppliedClip* appliedClip() const)
+    UNIMPL(bool usesMSAASurface() const)
+    UNIMPL(sktext::gpu::StrikeCache* strikeCache() const)
+    UNIMPL(GrAtlasManager* atlasManager() const)
+    UNIMPL(SkTArray<GrSurfaceProxy*, true>* sampledProxyArray())
+    UNIMPL(GrDeferredUploadTarget* deferredUploadTarget())
+#undef UNIMPL
+
+private:
+    sk_sp<GrDirectContext> fD3D11Context;
+    char fStaticVertexData[6 * 1024 * 1024];
+    sk_sp<GrGpuBuffer> fStaticVertexBuffer;
+    char fStaticIndirectData[sizeof(GrDrawIndexedIndirectCommand) * 32];
+    sk_sp<GrGpuBuffer> fStaticIndirectBuffer;
+    SkSTArenaAllocWithReset<1024 * 1024> fAllocator;
+    GrDstProxyView fDstProxyView;
+};
+
+#endif
diff --git a/src/gpu/ganesh/d3d11/GrD3D11OpsRenderPass.cpp b/src/gpu/ganesh/d3d11/GrD3D11OpsRenderPass.cpp
new file mode 100644
index 0000000000..976796eed0
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11OpsRenderPass.cpp
@@ -0,0 +1,301 @@
+
+#include "src/gpu/ganesh/d3d11/GrD3D11OpsRenderPass.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Texture.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11RenderTarget.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11TextureRenderTarget.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Attachment.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Buffer.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11ProgramBuilder.h"
+#include "src/gpu/ganesh/GrProgramDesc.h"
+#include "src/gpu/ganesh/GrProgramInfo.h"
+#include "src/gpu/ganesh/GrStencilSettings.h"
+#include "src/gpu/ganesh/GrOpFlushState.h"
+
+#ifdef SK_DEBUG
+#include "include/gpu/ganesh/GrDirectContext.h"
+#include "src/gpu/ganesh/GrDirectContextPriv.h"
+#endif
+
+GrD3D11OpsRenderPass::GrD3D11OpsRenderPass(GrD3D11Gpu* gpu) 
+	: fGpu(gpu) 
+{}
+
+bool GrD3D11OpsRenderPass::set(GrRenderTarget* rt,
+                             GrSurfaceOrigin origin,
+                             const SkIRect& bounds,
+                             const GrOpsRenderPass::LoadAndStoreInfo& colorInfo,
+                             const GrOpsRenderPass::StencilLoadAndStoreInfo& stencilInfo,
+                             const skia_private::TArray<GrSurfaceProxy*, true>& sampledProxies) {
+    SkASSERT(!fRenderTarget);
+    SkASSERT(fGpu == rt->getContext()->priv().getGpu());
+
+    this->INHERITED::set(rt, origin);
+
+    fBounds = bounds;
+
+    fColorLoadOp = colorInfo.fLoadOp;
+    fClearColor = colorInfo.fClearColor;
+    fStencilLoadOp = stencilInfo.fLoadOp;
+
+    // TODO
+
+    return true;
+}
+
+GrD3D11OpsRenderPass::~GrD3D11OpsRenderPass() {}
+
+GrGpu* GrD3D11OpsRenderPass::gpu() { return fGpu; }
+
+void GrD3D11OpsRenderPass::onBegin() {
+    GrD3D11RenderTarget* d3dRT = static_cast<GrD3D11RenderTarget*>(fRenderTarget);
+    SkASSERT(d3dRT->numSamples() == 1);
+    
+    ID3D11RenderTargetView* colorView = d3dRT->colorRenderTargetView();
+    auto stencil = d3dRT->getStencilAttachment();
+    GrD3D11Attachment* d3d11Stencil = static_cast<GrD3D11Attachment*>(stencil);
+    ID3D11DepthStencilView* pDepthStencilView = nullptr;
+
+    if (d3d11Stencil) {
+        pDepthStencilView = (ID3D11DepthStencilView*) d3d11Stencil->view();
+    }
+
+    //D3D11 WARNING: ID3D11DeviceContext::OMSetRenderTargets: Resource being set to OM RenderTarget slot 0 is still bound on input!
+    ID3D11ShaderResourceView* const pSRV[1] = {nullptr};
+    fGpu->deviceContext()->PSSetShaderResources(0, 1, pSRV);
+    fGpu->deviceContext()->PSSetShaderResources(1, 1, pSRV);
+    fGpu->deviceContext()->PSSetShaderResources(2, 1, pSRV);
+    fGpu->deviceContext()->PSSetShaderResources(3, 1, pSRV);
+
+    fGpu->deviceContext()->OMSetRenderTargets(1, &colorView, pDepthStencilView);
+
+    if (GrLoadOp::kClear == fColorLoadOp) {
+        fGpu->deviceContext()->ClearRenderTargetView(colorView, fClearColor.data());
+    }
+
+    if (pDepthStencilView) {
+        if (fStencilLoadOp == GrLoadOp::kClear) {
+            fGpu->deviceContext()->ClearDepthStencilView(
+                    pDepthStencilView, D3D11_CLEAR_STENCIL, 0, 0);
+        }
+    }
+}
+
+static void set_primitive_topology(GrD3D11Gpu* gpu, const GrProgramInfo& info) {
+    D3D11_PRIMITIVE_TOPOLOGY topology = D3D_PRIMITIVE_TOPOLOGY_UNDEFINED;
+    switch (info.primitiveType()) {
+        case GrPrimitiveType::kTriangles:
+            topology = D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
+            break;
+        case GrPrimitiveType::kTriangleStrip:
+            topology = D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP;
+            break;
+        case GrPrimitiveType::kPoints:
+            topology = D3D11_PRIMITIVE_TOPOLOGY_POINTLIST;
+            break;
+        case GrPrimitiveType::kLines:
+            topology = D3D11_PRIMITIVE_TOPOLOGY_LINELIST;
+            break;
+        case GrPrimitiveType::kLineStrip:
+            topology = D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP;
+            break;
+        default:
+            SkUNREACHABLE;
+    }
+
+    gpu->deviceContext()->IASetPrimitiveTopology(topology);
+}
+
+static void set_scissor_rects(GrD3D11Gpu* gpu,
+                       const GrRenderTarget* renderTarget,
+                       GrSurfaceOrigin rtOrigin,
+                       const SkIRect& scissorRect) {
+    SkASSERT(scissorRect.isEmpty() ||
+             SkIRect::MakeWH(renderTarget->width(), renderTarget->height()).contains(scissorRect));
+
+    D3D11_RECT scissor;
+    scissor.left = scissorRect.fLeft;
+    scissor.right = scissorRect.fRight;
+    if (kTopLeft_GrSurfaceOrigin == rtOrigin) {
+        scissor.top = scissorRect.fTop;
+    } else {
+        SkASSERT(kBottomLeft_GrSurfaceOrigin == rtOrigin);
+        scissor.top = renderTarget->height() - scissorRect.fBottom;
+    }
+    scissor.bottom = scissor.top + scissorRect.height();
+
+    SkASSERT(scissor.left >= 0);
+    SkASSERT(scissor.top >= 0);
+    gpu->deviceContext()->RSSetScissorRects(1, &scissor);
+}
+
+static void set_viewport(GrD3D11Gpu* gpu, const GrRenderTarget* renderTarget) {
+    D3D11_VIEWPORT viewport;
+    viewport.TopLeftX = 0.0f;
+    viewport.TopLeftY = 0.0f;
+    viewport.Width = SkIntToScalar(renderTarget->width());
+    viewport.Height = SkIntToScalar(renderTarget->height());
+    viewport.MinDepth = 0.0f;
+    viewport.MaxDepth = 1.0f;
+    gpu->deviceContext()->RSSetViewports(1, &viewport);
+}
+
+bool GrD3D11OpsRenderPass::onBindPipeline(const GrProgramInfo& info, const SkRect& drawBounds) {
+    SkRect rtRect = SkRect::Make(fBounds);
+    if (rtRect.intersect(drawBounds)) {
+        rtRect.roundOut(&fCurrentPipelineBounds);
+    } else {
+        fCurrentPipelineBounds.setEmpty();
+    }
+
+    GrD3D11RenderTarget* d3d11RT = static_cast<GrD3D11RenderTarget*>(fRenderTarget);
+    fCurrentProgram = fGpu->resourceProvider().findOrCreateProgram(d3d11RT, info);
+    if (!fCurrentProgram) {
+        return false;
+    }
+    fGpu->deviceContext()->IASetInputLayout(fCurrentProgram->fInputLayout.get());
+    fGpu->deviceContext()->VSSetShader(fCurrentProgram->fVertexShader.get(), nullptr, 0);
+    fGpu->deviceContext()->PSSetShader(fCurrentProgram->fPixelShader.get(), nullptr, 0);
+
+    fCurrentProgram->setAndBindConstants(fGpu, fRenderTarget, info);
+    fCurrentProgram->setBlendState(fGpu, info);
+    fCurrentProgram->setDepthStencilState(fGpu, info);
+    fCurrentProgram->setRasterizerState(fGpu, info);
+
+    set_primitive_topology(fGpu, info);
+    if (!info.pipeline().isScissorTestEnabled()) {
+        // "Disable" scissor by setting it to the full pipeline bounds.
+        set_scissor_rects(fGpu, fRenderTarget, fOrigin, fCurrentPipelineBounds);
+    }
+    set_viewport(fGpu, fRenderTarget);
+
+    return true;
+}
+
+void GrD3D11OpsRenderPass::onSetScissorRect(const SkIRect& scissor) {
+    SkIRect combinedScissorRect;
+    if (!combinedScissorRect.intersect(fCurrentPipelineBounds, scissor)) {
+        combinedScissorRect = SkIRect::MakeEmpty();
+    }
+
+    set_scissor_rects(fGpu, fRenderTarget, fOrigin, combinedScissorRect);
+}
+
+bool GrD3D11OpsRenderPass::onBindTextures(const GrGeometryProcessor& geomProc,
+                                        const GrSurfaceProxy* const geomProcTextures[],
+                                        const GrPipeline& pipeline) {
+    SkASSERT(fCurrentProgram);
+
+    fCurrentProgram->setAndBindTextures(fGpu, geomProc, geomProcTextures, pipeline);
+    return true;
+}
+
+void GrD3D11OpsRenderPass::onBindBuffers(sk_sp<const GrBuffer> indexBuffer,
+                                       sk_sp<const GrBuffer> instanceBuffer,
+                                       sk_sp<const GrBuffer> vertexBuffer,
+                                       GrPrimitiveRestart primRestart) {
+    SkASSERT(GrPrimitiveRestart::kNo == primRestart);
+    SkASSERT(fCurrentProgram);
+    SkASSERT(!fGpu->caps()->usePrimitiveRestart());  // Ignore primitiveRestart parameter.
+
+    //  Here our vertex and instance inputs need to match the same 0-based bindings they were
+    // assigned in the PipelineState. That is, vertex first (if any) followed by instance.
+    UINT numBuffers = 0;
+    ID3D11Buffer* buffers[2];
+    UINT strides[2];
+    UINT offsets[2];
+
+    if (vertexBuffer) {
+        auto* d3dBuffer = static_cast<const GrD3D11Buffer*>(vertexBuffer.get());
+        buffers[numBuffers] = d3dBuffer->d3d11Resource();
+        strides[numBuffers] = fCurrentProgram->fVertexStride;
+        offsets[numBuffers++] = 0;
+    }
+
+    if (instanceBuffer) {
+        auto* d3dBuffer = static_cast<const GrD3D11Buffer*>(instanceBuffer.get());
+        buffers[numBuffers] = d3dBuffer->d3d11Resource();
+        strides[numBuffers] = fCurrentProgram->fInstanceStride;
+        offsets[numBuffers++] = 0;
+    }
+
+    fGpu->deviceContext()->IASetVertexBuffers(0, numBuffers, buffers, strides, offsets);
+
+    if (auto* d3dIndexBuffer = static_cast<const GrD3D11Buffer*>(indexBuffer.get())) {
+        SkASSERT(!d3dIndexBuffer->isCpuBuffer());
+        SkASSERT(!d3dIndexBuffer->isMapped());
+
+        auto* d3dBuffer = static_cast<const GrD3D11Buffer*>(indexBuffer.get());
+        fGpu->deviceContext()->IASetIndexBuffer(
+                d3dBuffer->d3d11Resource(), DXGI_FORMAT_R16_UINT, 0);
+    }
+
+    fActiveInstanceBuffer = std::move(instanceBuffer);
+    fActiveVertexBuffer = std::move(vertexBuffer);
+    fActiveIndexBuffer = std::move(indexBuffer);
+}
+
+void GrD3D11OpsRenderPass::onDrawInstanced(int instanceCount,
+                                         int baseInstance,
+                                         int vertexCount,
+                                         int baseVertex) {
+    fGpu->deviceContext()->DrawInstanced(vertexCount, instanceCount, baseVertex, baseInstance);
+    fGpu->stats()->incNumDraws();
+}
+
+void GrD3D11OpsRenderPass::onDrawIndexedInstanced(
+        int indexCount, int baseIndex, int instanceCount, int baseInstance, int baseVertex) {
+    fGpu->deviceContext()->DrawIndexedInstanced(
+            indexCount, instanceCount, baseIndex, baseVertex, baseInstance);
+    fGpu->stats()->incNumDraws();
+}
+
+void GrD3D11OpsRenderPass::onClear(const GrScissorState& scissor, std::array<float, 4> color) {
+    SkASSERT(!scissor.enabled() || fGpu->caps()->performPartialClearsAsDraws());
+
+    auto d3dRT = static_cast<GrD3D11RenderTarget*>(fRenderTarget);
+    fGpu->deviceContext()->ClearRenderTargetView(d3dRT->colorRenderTargetView(), color.data());
+}
+
+void GrD3D11OpsRenderPass::onClearStencilClip(const GrScissorState& scissor, bool insideStencilMask) {
+    SkASSERT(!scissor.enabled() || fGpu->caps()->performPartialClearsAsDraws());
+
+    GrAttachment* sb = fRenderTarget->getStencilAttachment();
+    // this should only be called internally when we know we have a
+    // stencil buffer.
+    SkASSERT(sb);
+    int stencilBitCount = GrBackendFormatStencilBits(sb->backendFormat());
+
+    // The contract with the callers does not guarantee that we preserve all bits in the stencil
+    // during this clear. Thus we will clear the entire stencil to the desired value.
+
+    uint8_t stencilColor = 0;
+    if (insideStencilMask) {
+        stencilColor = (1 << (stencilBitCount - 1));
+    }
+
+    auto d3dStencil = static_cast<GrD3D11Attachment*>(sb);
+    fGpu->deviceContext()->ClearDepthStencilView((ID3D11DepthStencilView*)d3dStencil->view(),
+                                                 D3D11_CLEAR_STENCIL, 0, stencilColor);
+}
+
+void GrD3D11OpsRenderPass::inlineUpload(GrOpFlushState* state, GrDeferredTextureUploadFn& upload) {
+    // If we ever start using copy command lists for doing uploads, then we'll need to make sure
+    // we submit our main command list before doing the copy here and then start a new main command
+    // list.
+    fGpu->endRenderPass(fRenderTarget, fOrigin, fBounds);
+
+    // We pass in true here to signal that after the upload we need to set the upload texture's
+    // resource state back to D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE.
+    state->doUpload(upload, true);
+}
+
+void GrD3D11OpsRenderPass::submit() {
+    if (!fRenderTarget) {
+        return;
+    }
+    // We don't use render passes in d3d, so there is nothing to submit here as all commands have
+    // already been recorded on the main command list. If in the future we start to use render
+    // passes on d3d12 devices that support them (most likely ARM devices), then we
+    // will submit them here.
+    fGpu->endRenderPass(fRenderTarget, fOrigin, fBounds);
+}
diff --git a/src/gpu/ganesh/d3d11/GrD3D11OpsRenderPass.h b/src/gpu/ganesh/d3d11/GrD3D11OpsRenderPass.h
new file mode 100644
index 0000000000..cab3beb336
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11OpsRenderPass.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef GrD3D11OpsRenderPass_DEFINED
+#define GrD3D11OpsRenderPass_DEFINED
+
+#include "src/gpu/ganesh/GrOpsRenderPass.h"
+
+#include "src/gpu/ganesh/GrTexture.h"
+
+class GrD3D11Gpu;
+struct GrD3D11Program;
+
+class GrD3D11OpsRenderPass : public GrOpsRenderPass {
+public:
+    GrD3D11OpsRenderPass(GrD3D11Gpu* gpu);
+
+    ~GrD3D11OpsRenderPass() override;
+
+    void inlineUpload(GrOpFlushState* state, GrDeferredTextureUploadFn& upload) override;
+
+    void onExecuteDrawable(std::unique_ptr<SkDrawable::GpuDrawHandler>) override {}
+
+    bool set(GrRenderTarget*,
+             GrSurfaceOrigin,
+             const SkIRect& bounds,
+             const GrOpsRenderPass::LoadAndStoreInfo&,
+             const GrOpsRenderPass::StencilLoadAndStoreInfo&,
+             const skia_private::TArray<GrSurfaceProxy*, true>& sampledProxies);
+
+    void submit();
+
+private:
+    GrGpu* gpu() override;
+
+    void onBegin() override;
+
+    bool onBindPipeline(const GrProgramInfo&, const SkRect& drawBounds) override;
+    void onSetScissorRect(const SkIRect&) override;
+    bool onBindTextures(const GrGeometryProcessor&,
+                        const GrSurfaceProxy* const geomProcTextures[],
+                        const GrPipeline&) override;
+    void onBindBuffers(sk_sp<const GrBuffer> indexBuffer, sk_sp<const GrBuffer> instanceBuffer,
+                       sk_sp<const GrBuffer> vertexBuffer, GrPrimitiveRestart) override;
+    void onDraw(int vertexCount, int baseVertex) override {
+        this->onDrawInstanced(1, 0, vertexCount, baseVertex);
+    }
+    void onDrawIndexed(int indexCount, int baseIndex, uint16_t minIndexValue,
+                       uint16_t maxIndexValue, int baseVertex) override {
+        this->onDrawIndexedInstanced(indexCount, baseIndex, 1, 0, baseVertex);
+    }
+    void onDrawInstanced(int instanceCount, int baseInstance, int vertexCount,
+                         int baseVertex) override;
+    void onDrawIndexedInstanced(int indexCount, int baseIndex, int instanceCount, int baseInstance,
+                                int baseVertex) override;
+
+    void onClear(const GrScissorState& scissor, std::array<float, 4> color) override;
+
+    void onClearStencilClip(const GrScissorState& scissor, bool insideStencilMask) override;
+
+    GrD3D11Gpu* fGpu;
+
+    SkIRect fBounds;
+    SkIRect fCurrentPipelineBounds;
+
+    GrLoadOp fColorLoadOp;
+    std::array<float, 4> fClearColor;
+    GrLoadOp fStencilLoadOp;
+
+    GrD3D11Program* fCurrentProgram = nullptr;
+
+    using INHERITED = GrOpsRenderPass;
+};
+
+#endif
diff --git a/src/gpu/ganesh/d3d11/GrD3D11ProgramBuilder.cpp b/src/gpu/ganesh/d3d11/GrD3D11ProgramBuilder.cpp
new file mode 100644
index 0000000000..c3fcde8da3
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11ProgramBuilder.cpp
@@ -0,0 +1,779 @@
+/*
+ * Copyright 2020 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+//#include <d3dcompiler.h>
+
+#include "src/gpu/ganesh/d3d11/GrD3D11ProgramBuilder.h"
+
+#include "include/private/base/SkTemplates.h"
+#include "include/gpu/ganesh/GrDirectContext.h"
+#include "src/core/SkReadBuffer.h"
+#include "src/core/SkTraceEvent.h"
+#include "src/gpu/ganesh/GrAutoLocaleSetter.h"
+#include "src/gpu/ganesh/GrDirectContextPriv.h"
+#include "src/gpu/ganesh/GrPersistentCacheUtils.h"
+#include "src/gpu/ganesh/GrShaderCaps.h"
+#include "src/gpu/ganesh/GrStencilSettings.h"
+#include "src/gpu/ganesh/effects/GrTextureEffect.h"
+
+#include "src/gpu/ganesh/d3d11/GrD3D11Gpu.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Texture.h"
+#include "src/sksl/SkSLCompiler.h"
+#include "src/sksl/SkSLProgramKind.h"
+#include "src/sksl/SkSLProgramSettings.h"
+#include "src/utils/SkShaderUtils.h"
+
+#include <d3dcompiler.h>
+
+GrD3D11Program::GrD3D11Program(
+        gr_cp<ID3D11VertexShader> vertexShader,
+               gr_cp<ID3D11PixelShader> pixelShader,
+               gr_cp<ID3D11InputLayout> inputLayout,
+               gr_cp<ID3D11BlendState> blendState,
+               gr_cp<ID3D11RasterizerState> rasterizerState,
+               gr_cp<ID3D11DepthStencilState> depthStencilState,
+               const GrGLSLBuiltinUniformHandles& builtinUniformHandles,
+               const UniformInfoArray& uniforms,
+               uint32_t uniformSize,
+               uint32_t numSamplers,
+               std::unique_ptr<GrGeometryProcessor::ProgramImpl> gpImpl,
+               std::unique_ptr<GrXferProcessor::ProgramImpl> xpImpl,
+               std::vector<std::unique_ptr<GrFragmentProcessor::ProgramImpl>> fpImpls,
+               size_t vertexStride,
+               size_t instanceStride): 
+    fNumSamplers(numSamplers), 
+    fVertexStride(vertexStride), 
+    fInstanceStride(instanceStride), 
+    fBuiltinUniformHandles(builtinUniformHandles), 
+    fDataManager(uniforms, uniformSize),
+    fGPImpl(std::move(gpImpl)),
+    fXPImpl(std::move(xpImpl)),
+    fFPImpls(std::move(fpImpls)),
+    fVertexShader(vertexShader),
+    fPixelShader(pixelShader),
+    fInputLayout(inputLayout),
+    fBlendState(std::move(blendState)),
+    fRasterizerState(std::move(rasterizerState)),
+    fDepthStencilState(std::move(depthStencilState))
+{
+}
+
+void GrD3D11Program::setAndBindConstants(GrD3D11Gpu* gpu,
+                                             const GrRenderTarget* renderTarget,
+                                             const GrProgramInfo& programInfo) {
+    this->setRenderTargetState(renderTarget, programInfo.origin());
+
+    fGPImpl->setData(fDataManager, *gpu->caps()->shaderCaps(), programInfo.geomProc());
+
+    for (int i = 0; i < programInfo.pipeline().numFragmentProcessors(); ++i) {
+        const auto& fp = programInfo.pipeline().getFragmentProcessor(i);
+        fp.visitWithImpls(
+                [&](const GrFragmentProcessor& fp, GrFragmentProcessor::ProgramImpl& impl) {
+                    impl.setData(fDataManager, fp);
+                },
+                *fFPImpls[i]);
+    }
+
+    programInfo.pipeline().setDstTextureUniforms(fDataManager, &fBuiltinUniformHandles);
+    fXPImpl->setData(fDataManager, programInfo.pipeline().getXferProcessor());
+
+    fDataManager.uploadConstants(gpu);
+}
+
+void GrD3D11Program::setRenderTargetState(const GrRenderTarget* rt, GrSurfaceOrigin origin) {
+    // Set RT adjustment and RT flip
+    SkISize dimensions = rt->dimensions();
+    SkASSERT(fBuiltinUniformHandles.fRTAdjustmentUni.isValid());
+    if (fRenderTargetState.fRenderTargetOrigin != origin ||
+        fRenderTargetState.fRenderTargetSize != dimensions) {
+        fRenderTargetState.fRenderTargetSize = dimensions;
+        fRenderTargetState.fRenderTargetOrigin = origin;
+
+        // The client will mark a swap buffer as kTopLeft when making a SkSurface because
+        // D3D's framebuffer space has (0, 0) at the top left. This agrees with Skia's device
+        // coords. However, in NDC (-1, -1) is the bottom left. So we flip when origin is kTopLeft.
+        bool flip = (origin == kTopLeft_GrSurfaceOrigin);
+        std::array<float, 4> v = SkSL::Compiler::GetRTAdjustVector(dimensions, flip);
+        fDataManager.set4fv(fBuiltinUniformHandles.fRTAdjustmentUni, 1, v.data());
+        if (fBuiltinUniformHandles.fRTFlipUni.isValid()) {
+            // Note above that framebuffer space has origin top left. So we need !flip here.
+            std::array<float, 2> d = SkSL::Compiler::GetRTFlipVector(rt->height(), !flip);
+            fDataManager.set2fv(fBuiltinUniformHandles.fRTFlipUni, 1, d.data());
+        }
+    }
+}
+
+void GrD3D11Program::setAndBindTextures(GrD3D11Gpu* gpu,
+                                            const GrGeometryProcessor& geomProc,
+                                            const GrSurfaceProxy* const geomProcTextures[],
+                                            const GrPipeline& pipeline) {
+    SkASSERT(geomProcTextures || !geomProc.numTextureSamplers());
+
+    if (fNumSamplers == 0)
+        return;
+
+    UINT startSlot = 0;
+    for (int i = 0; i < geomProc.numTextureSamplers(); ++i) {
+        SkASSERT(geomProcTextures[i]->asTextureProxy());
+        const auto& sampler = geomProc.textureSampler(i);
+        auto texture = static_cast<GrD3D11Texture*>(geomProcTextures[i]->peekTexture());
+        auto d3d11View = texture->shaderResourceView();
+        auto d3d11Sampler = gpu->resourceProvider().findOrCreateCompatibleSampler(sampler.samplerState());
+
+        gpu->deviceContext()->PSSetSamplers(startSlot * 2, 1, &d3d11Sampler);           //GrD3DRootSignature.cpp BaseShaderRegister
+        gpu->deviceContext()->PSSetShaderResources(startSlot * 2 + 1, 1, &d3d11View);
+        startSlot++;
+    }
+
+    if (GrTexture* dstTexture = pipeline.peekDstTexture()) {
+        auto texture = static_cast<GrD3D11Texture*>(dstTexture);
+        auto d3d11View = texture->shaderResourceView();
+        auto d3d11Sampler = gpu->resourceProvider().findOrCreateCompatibleSampler(
+                GrSamplerState::Filter::kNearest);
+
+        gpu->deviceContext()->PSSetSamplers(startSlot * 2, 1, &d3d11Sampler);
+        gpu->deviceContext()->PSSetShaderResources(startSlot * 2 + 1, 1, &d3d11View);
+        startSlot++;
+    }
+
+    pipeline.visitTextureEffects([&](const GrTextureEffect& te) {
+        GrSamplerState samplerState = te.samplerState();
+        auto* texture = static_cast<GrD3D11Texture*>(te.texture());
+        auto d3d11View = texture->shaderResourceView();
+        auto d3d11Sampler =
+                gpu->resourceProvider().findOrCreateCompatibleSampler(samplerState);
+
+        gpu->deviceContext()->PSSetSamplers(startSlot * 2, 1, &d3d11Sampler);
+        gpu->deviceContext()->PSSetShaderResources(startSlot * 2 + 1, 1, &d3d11View);
+        startSlot++;
+    });
+
+    SkASSERT(fNumSamplers == startSlot);
+}
+
+static void get_blend_factor(const GrProgramInfo& info, float* floatColors) {
+    const GrXferProcessor& xferProcessor = info.pipeline().getXferProcessor();
+    const skgpu::Swizzle& swizzle = info.pipeline().writeSwizzle();
+    const skgpu::BlendInfo& blendInfo = xferProcessor.getBlendInfo();
+    skgpu::BlendCoeff srcCoeff = blendInfo.fSrcBlend;
+    skgpu::BlendCoeff dstCoeff = blendInfo.fDstBlend;
+    if (skgpu::BlendCoeffRefsConstant(srcCoeff) || skgpu::BlendCoeffRefsConstant(dstCoeff)) {
+        // Swizzle the blend to match what the shader will output.
+        SkPMColor4f blendConst = swizzle.applyTo(blendInfo.fBlendConstant);
+        floatColors[0] = blendConst.fR;
+        floatColors[1] = blendConst.fG;
+        floatColors[2] = blendConst.fB;
+        floatColors[3] = blendConst.fA;
+    } else {
+        memset(floatColors, 0, 4 * sizeof(float));
+    }
+}
+
+unsigned int get_stencil_ref(const GrProgramInfo& info) {
+    GrStencilSettings stencilSettings = info.nonGLStencilSettings();
+    unsigned int stencilRef = 0;
+    if (!stencilSettings.isDisabled()) {
+        if (stencilSettings.isTwoSided()) {
+            SkASSERT(stencilSettings.postOriginCCWFace(info.origin()).fRef ==
+                     stencilSettings.postOriginCWFace(info.origin()).fRef);
+            stencilRef = stencilSettings.postOriginCCWFace(info.origin()).fRef;
+        } else {
+            stencilRef = stencilSettings.singleSidedFace().fRef;
+        }
+    }
+
+    return stencilRef;
+}
+
+void GrD3D11Program::setBlendState(GrD3D11Gpu* gpu, const GrProgramInfo& programInfo) {
+    FLOAT blendFactor[4];
+    get_blend_factor(programInfo, blendFactor);
+    gpu->deviceContext()->OMSetBlendState(fBlendState.get(), blendFactor, 0xFFFFFFFF);
+}
+
+void GrD3D11Program::setDepthStencilState(GrD3D11Gpu* gpu, const GrProgramInfo& programInfo) {
+    gpu->deviceContext()->OMSetDepthStencilState(fDepthStencilState.get(),
+                                                 get_stencil_ref(programInfo));
+}
+
+void GrD3D11Program::setRasterizerState(GrD3D11Gpu* gpu, const GrProgramInfo& programInfo) {
+    gpu->deviceContext()->RSSetState(fRasterizerState.get());
+}
+
+
+
+std::unique_ptr<GrD3D11Program> GrD3D11ProgramBuilder::MakeD3D11Program(
+        GrD3D11Gpu* gpu,
+        const GrProgramDesc& desc,
+        const GrProgramInfo& programInfo) {
+    // ensure that we use "." as a decimal separator when creating SkSL code
+    GrAutoLocaleSetter als("C");
+
+    // create a builder.  This will be handed off to effects so they can use it to add
+    // uniforms, varyings, textures, etc
+    GrD3D11ProgramBuilder builder(gpu, desc, programInfo);
+
+    if (!builder.emitAndInstallProcs()) {
+        return nullptr;
+    }
+
+    return builder.finalize();
+}
+
+GrD3D11ProgramBuilder::GrD3D11ProgramBuilder(GrD3D11Gpu* gpu,
+                                                     const GrProgramDesc& desc,
+                                                     const GrProgramInfo& programInfo)
+        : INHERITED(desc, programInfo)
+        , fGpu(gpu)
+        , fVaryingHandler(this)
+        , fUniformHandler(this) 
+{}
+
+const GrCaps* GrD3D11ProgramBuilder::caps() const {
+    return fGpu->caps();
+}
+
+void GrD3D11ProgramBuilder::finalizeFragmentSecondaryColor(GrShaderVar& outputColor) {
+    outputColor.addLayoutQualifier("location = 0, index = 1");
+}
+
+// Print the source code for all shaders generated.
+static const bool gPrintSKSL = false;
+static const bool gPrintHLSL = false;
+
+static gr_cp<ID3DBlob> GrCompileHLSLShader(GrD3D11Gpu* gpu,
+                                           const std::string& hlsl,
+                                           SkSL::ProgramKind kind) {
+    TRACE_EVENT0("skia.shaders", "driver_compile_shader");
+    const char* compileTarget = nullptr;
+    switch (kind) {
+        case SkSL::ProgramKind::kVertex:
+            compileTarget = "vs_5_0";
+            break;
+        case SkSL::ProgramKind::kFragment:
+            compileTarget = "ps_5_0";
+            break;
+        default:
+            SkUNREACHABLE;
+    }
+
+    uint32_t compileFlags = 0;
+#ifdef SK_DEBUG
+    // Enable better shader debugging with the graphics debugging tools.
+    compileFlags |= D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION;
+#endif
+    // SPRIV-cross does matrix multiplication expecting row major matrices
+    compileFlags |= D3DCOMPILE_PACK_MATRIX_ROW_MAJOR;
+
+    gr_cp<ID3DBlob> shader;
+    gr_cp<ID3DBlob> errors;
+    HRESULT hr = D3DCompile(hlsl.c_str(), hlsl.length(), nullptr, nullptr, nullptr, "main",
+                            compileTarget, compileFlags, 0, &shader, &errors);
+    if (!SUCCEEDED(hr)) {
+        gpu->getContext()->priv().getShaderErrorHandler()->compileError(
+                hlsl.c_str(), reinterpret_cast<char*>(errors->GetBufferPointer()));
+    }
+    return shader;
+}
+
+bool GrD3D11ProgramBuilder::loadHLSLFromCache(SkReadBuffer* reader, gr_cp<ID3DBlob> shaders[]) {
+
+    std::string hlsl[kGrShaderTypeCount];
+    SkSL::Program::Interface intfs[kGrShaderTypeCount];
+
+    if (!GrPersistentCacheUtils::UnpackCachedShaders(reader, hlsl, intfs, kGrShaderTypeCount)) {
+        return false;
+    }
+
+    auto compile = [&](SkSL::ProgramKind kind, GrShaderType shaderType) {
+        if (intfs[shaderType].fRTFlipUniform != SkSL::Program::Interface::kRTFlip_None) {
+            this->addRTFlipUniform(SKSL_RTFLIP_NAME);
+        }
+        shaders[shaderType] = GrCompileHLSLShader(fGpu, hlsl[shaderType], kind);
+        return shaders[shaderType].get();
+    };
+
+    return compile(SkSL::ProgramKind::kVertex, kVertex_GrShaderType) &&
+           compile(SkSL::ProgramKind::kFragment, kFragment_GrShaderType);
+}
+
+gr_cp<ID3DBlob> GrD3D11ProgramBuilder::compileD3D11Program(
+        SkSL::ProgramKind kind,
+        const std::string& sksl,
+        const SkSL::ProgramSettings& settings,
+        SkSL::Program::Interface* outInterface,
+        std::string* outHLSL) {
+
+    extern int shader_model;
+    shader_model = 50;
+
+    if (!skgpu::SkSLToHLSL(this->caps()->shaderCaps(),
+                           sksl,
+                           kind,
+                           settings,
+                           outHLSL,
+                           outInterface,
+                           fGpu->getContext()->priv().getShaderErrorHandler())) {
+        return gr_cp<ID3DBlob>();
+    }
+
+    if (outInterface->fRTFlipUniform != SkSL::Program::Interface::kRTFlip_None) {
+        this->addRTFlipUniform(SKSL_RTFLIP_NAME);
+    }
+
+    return GrCompileHLSLShader(fGpu, *outHLSL, kind);
+}
+
+static DXGI_FORMAT attrib_type_to_format(GrVertexAttribType type) {
+    switch (type) {
+    case kFloat_GrVertexAttribType:
+        return DXGI_FORMAT_R32_FLOAT;
+    case kFloat2_GrVertexAttribType:
+        return DXGI_FORMAT_R32G32_FLOAT;
+    case kFloat3_GrVertexAttribType:
+        return DXGI_FORMAT_R32G32B32_FLOAT;
+    case kFloat4_GrVertexAttribType:
+        return DXGI_FORMAT_R32G32B32A32_FLOAT;
+    case kHalf_GrVertexAttribType:
+        return DXGI_FORMAT_R16_FLOAT;
+    case kHalf2_GrVertexAttribType:
+        return DXGI_FORMAT_R16G16_FLOAT;
+    case kHalf4_GrVertexAttribType:
+        return DXGI_FORMAT_R16G16B16A16_FLOAT;
+    case kInt2_GrVertexAttribType:
+        return DXGI_FORMAT_R32G32_SINT;
+    case kInt3_GrVertexAttribType:
+        return DXGI_FORMAT_R32G32B32_SINT;
+    case kInt4_GrVertexAttribType:
+        return DXGI_FORMAT_R32G32B32A32_SINT;
+    case kByte_GrVertexAttribType:
+        return DXGI_FORMAT_R8_SINT;
+    case kByte2_GrVertexAttribType:
+        return DXGI_FORMAT_R8G8_SINT;
+    case kByte4_GrVertexAttribType:
+        return DXGI_FORMAT_R8G8B8A8_SINT;
+    case kUByte_GrVertexAttribType:
+        return DXGI_FORMAT_R8_UINT;
+    case kUByte2_GrVertexAttribType:
+        return DXGI_FORMAT_R8G8_UINT;
+    case kUByte4_GrVertexAttribType:
+        return DXGI_FORMAT_R8G8B8A8_UINT;
+    case kUByte_norm_GrVertexAttribType:
+        return DXGI_FORMAT_R8_UNORM;
+    case kUByte4_norm_GrVertexAttribType:
+        return DXGI_FORMAT_R8G8B8A8_UNORM;
+    case kShort2_GrVertexAttribType:
+        return DXGI_FORMAT_R16G16_SINT;
+    case kShort4_GrVertexAttribType:
+        return DXGI_FORMAT_R16G16B16A16_SINT;
+    case kUShort2_GrVertexAttribType:
+        return DXGI_FORMAT_R16G16_UINT;
+    case kUShort2_norm_GrVertexAttribType:
+        return DXGI_FORMAT_R16G16_UNORM;
+    case kInt_GrVertexAttribType:
+        return DXGI_FORMAT_R32_SINT;
+    case kUInt_GrVertexAttribType:
+        return DXGI_FORMAT_R32_UINT;
+    case kUShort_norm_GrVertexAttribType:
+        return DXGI_FORMAT_R16_UNORM;
+    case kUShort4_norm_GrVertexAttribType:
+        return DXGI_FORMAT_R16G16B16A16_UNORM;
+    }
+    SK_ABORT("Unknown vertex attrib type");
+}
+
+static void setup_vertex_input_layout(const GrGeometryProcessor& geomProc,
+                                      D3D11_INPUT_ELEMENT_DESC* inputElements) {
+    unsigned int slotNumber = 0;
+    unsigned int vertexSlot = 0;
+    unsigned int instanceSlot = 0;
+    if (geomProc.hasVertexAttributes()) {
+        vertexSlot = slotNumber++;
+    }
+    if (geomProc.hasInstanceAttributes()) {
+        instanceSlot = slotNumber++;
+    }
+
+    unsigned int currentAttrib = 0;
+
+    for (const auto& attrib : geomProc.vertexAttributes()) {
+        // When using SPIRV-Cross it converts the location modifier in SPIRV to be
+        // TEXCOORD<N> where N is the location value for eveery vertext attribute
+        inputElements[currentAttrib] = { "TEXCOORD", currentAttrib,
+                                        attrib_type_to_format(attrib.cpuType()),
+                                        vertexSlot, SkToU32(*attrib.offset()),
+                                        D3D11_INPUT_PER_VERTEX_DATA,
+                                        0};
+        currentAttrib++;
+    }
+
+    for (const auto& attrib : geomProc.instanceAttributes()) {
+        // When using SPIRV-Cross it converts the location modifier in SPIRV to be
+        // TEXCOORD<N> where N is the location value for eveery vertext attribute
+        inputElements[currentAttrib] = { "TEXCOORD", currentAttrib,
+                                        attrib_type_to_format(attrib.cpuType()),
+                                        instanceSlot, SkToU32(*attrib.offset()),
+                                        D3D11_INPUT_PER_INSTANCE_DATA,
+                                        1};
+        currentAttrib++;
+    }
+}
+
+static D3D11_BLEND blend_coeff_to_d3d11_blend(skgpu::BlendCoeff coeff) {
+    switch (coeff) {
+    case skgpu::BlendCoeff::kZero:
+        return D3D11_BLEND_ZERO;
+    case skgpu::BlendCoeff::kOne:
+        return D3D11_BLEND_ONE;
+    case skgpu::BlendCoeff::kSC:
+        return D3D11_BLEND_SRC_COLOR;
+    case skgpu::BlendCoeff::kISC:
+        return D3D11_BLEND_INV_SRC_COLOR;
+    case skgpu::BlendCoeff::kDC:
+        return D3D11_BLEND_DEST_COLOR;
+    case skgpu::BlendCoeff::kIDC:
+        return D3D11_BLEND_INV_DEST_COLOR;
+    case skgpu::BlendCoeff::kSA:
+        return D3D11_BLEND_SRC_ALPHA;
+    case skgpu::BlendCoeff::kISA:
+        return D3D11_BLEND_INV_SRC_ALPHA;
+    case skgpu::BlendCoeff::kDA:
+        return D3D11_BLEND_DEST_ALPHA;
+    case skgpu::BlendCoeff::kIDA:
+        return D3D11_BLEND_INV_DEST_ALPHA;
+    case skgpu::BlendCoeff::kConstC:
+        return D3D11_BLEND_BLEND_FACTOR;
+    case skgpu::BlendCoeff::kIConstC:
+        return D3D11_BLEND_INV_BLEND_FACTOR;
+    case skgpu::BlendCoeff::kS2C:
+        return D3D11_BLEND_SRC1_COLOR;
+    case skgpu::BlendCoeff::kIS2C:
+        return D3D11_BLEND_INV_SRC1_COLOR;
+    case skgpu::BlendCoeff::kS2A:
+        return D3D11_BLEND_SRC1_ALPHA;
+    case skgpu::BlendCoeff::kIS2A:
+        return D3D11_BLEND_INV_SRC1_ALPHA;
+    case skgpu::BlendCoeff::kIllegal:
+        return D3D11_BLEND_ZERO;
+    }
+    SkUNREACHABLE;
+}
+
+static D3D11_BLEND blend_coeff_to_d3d11_blend_for_alpha(skgpu::BlendCoeff coeff) {
+    switch (coeff) {
+        // Force all srcColor used in alpha slot to alpha version.
+    case skgpu::BlendCoeff::kSC:
+        return D3D11_BLEND_SRC_ALPHA;
+    case skgpu::BlendCoeff::kISC:
+        return D3D11_BLEND_INV_SRC_ALPHA;
+    case skgpu::BlendCoeff::kDC:
+        return D3D11_BLEND_DEST_ALPHA;
+    case skgpu::BlendCoeff::kIDC:
+        return D3D11_BLEND_INV_DEST_ALPHA;
+    case skgpu::BlendCoeff::kS2C:
+        return D3D11_BLEND_SRC1_ALPHA;
+    case skgpu::BlendCoeff::kIS2C:
+        return D3D11_BLEND_INV_SRC1_ALPHA;
+
+    default:
+        return blend_coeff_to_d3d11_blend(coeff);
+    }
+}
+
+
+static D3D11_BLEND_OP blend_equation_to_d3d11_op(skgpu::BlendEquation equation) {
+    switch (equation) {
+    case skgpu::BlendEquation::kAdd:
+        return D3D11_BLEND_OP_ADD;
+    case skgpu::BlendEquation::kSubtract:
+        return D3D11_BLEND_OP_SUBTRACT;
+    case skgpu::BlendEquation::kReverseSubtract:
+        return D3D11_BLEND_OP_REV_SUBTRACT;
+    default:
+        SkUNREACHABLE;
+    }
+}
+
+static void fill_in_blend_state(const GrPipeline& pipeline, D3D11_BLEND_DESC* blendDesc) {
+    blendDesc->AlphaToCoverageEnable = false;
+    blendDesc->IndependentBlendEnable = false;
+
+    const skgpu::BlendInfo& blendInfo = pipeline.getXferProcessor().getBlendInfo();
+
+    skgpu::BlendEquation equation = blendInfo.fEquation;
+    skgpu::BlendCoeff srcCoeff = blendInfo.fSrcBlend;
+    skgpu::BlendCoeff dstCoeff = blendInfo.fDstBlend;
+    bool blendOff = skgpu::BlendShouldDisable(equation, srcCoeff, dstCoeff);
+
+    auto& rtBlend = blendDesc->RenderTarget[0];
+    rtBlend.BlendEnable = !blendOff;
+    if (!blendOff) {
+        rtBlend.SrcBlend = blend_coeff_to_d3d11_blend(srcCoeff);
+        rtBlend.DestBlend = blend_coeff_to_d3d11_blend(dstCoeff);
+        rtBlend.BlendOp = blend_equation_to_d3d11_op(equation);
+        rtBlend.SrcBlendAlpha = blend_coeff_to_d3d11_blend_for_alpha(srcCoeff);
+        rtBlend.DestBlendAlpha = blend_coeff_to_d3d11_blend_for_alpha(dstCoeff);
+        rtBlend.BlendOpAlpha = blend_equation_to_d3d11_op(equation);
+    }
+
+    if (!blendInfo.fWritesColor) {
+        rtBlend.RenderTargetWriteMask = 0;
+    } else {
+        rtBlend.RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
+    }
+}
+
+static void fill_in_rasterizer_state(const GrPipeline& pipeline,
+                                     bool multisampleEnable,
+                                     const GrCaps* caps,
+                                     D3D11_RASTERIZER_DESC* rasterizer) {
+    rasterizer->FillMode = (caps->wireframeMode() || pipeline.isWireframe()) ?
+        D3D11_FILL_WIREFRAME : D3D11_FILL_SOLID;
+    rasterizer->CullMode = D3D11_CULL_NONE;
+    rasterizer->FrontCounterClockwise = true;
+    rasterizer->DepthBias = 0;
+    rasterizer->DepthBiasClamp = 0.0f;
+    rasterizer->SlopeScaledDepthBias = 0.0f;
+    rasterizer->DepthClipEnable = false;
+    rasterizer->ScissorEnable = true;
+    rasterizer->MultisampleEnable = multisampleEnable;
+    rasterizer->AntialiasedLineEnable = false;
+}
+
+static D3D11_STENCIL_OP stencil_op_to_d3d11_op(GrStencilOp op) {
+    switch (op) {
+    case GrStencilOp::kKeep:
+        return D3D11_STENCIL_OP_KEEP;
+    case GrStencilOp::kZero:
+        return D3D11_STENCIL_OP_ZERO;
+    case GrStencilOp::kReplace:
+        return D3D11_STENCIL_OP_REPLACE;
+    case GrStencilOp::kInvert:
+        return D3D11_STENCIL_OP_INVERT;
+    case GrStencilOp::kIncWrap:
+        return D3D11_STENCIL_OP_INCR;
+    case GrStencilOp::kDecWrap:
+        return D3D11_STENCIL_OP_DECR;
+    case GrStencilOp::kIncClamp:
+        return D3D11_STENCIL_OP_INCR_SAT;
+    case GrStencilOp::kDecClamp:
+        return D3D11_STENCIL_OP_DECR_SAT;
+    }
+    SkUNREACHABLE;
+}
+
+static D3D11_COMPARISON_FUNC stencil_test_to_d3d11_func(GrStencilTest test) {
+    switch (test) {
+    case GrStencilTest::kAlways:
+        return D3D11_COMPARISON_ALWAYS;
+    case GrStencilTest::kNever:
+        return D3D11_COMPARISON_NEVER;
+    case GrStencilTest::kGreater:
+        return D3D11_COMPARISON_GREATER;
+    case GrStencilTest::kGEqual:
+        return D3D11_COMPARISON_GREATER_EQUAL;
+    case GrStencilTest::kLess:
+        return D3D11_COMPARISON_LESS;
+    case GrStencilTest::kLEqual:
+        return D3D11_COMPARISON_LESS_EQUAL;
+    case GrStencilTest::kEqual:
+        return D3D11_COMPARISON_EQUAL;
+    case GrStencilTest::kNotEqual:
+        return D3D11_COMPARISON_NOT_EQUAL;
+    }
+    SkUNREACHABLE;
+}
+
+static void setup_stencilop_desc(D3D11_DEPTH_STENCILOP_DESC* desc,
+                                 const GrStencilSettings::Face& stencilFace) {
+    desc->StencilFailOp = stencil_op_to_d3d11_op(stencilFace.fFailOp);
+    desc->StencilDepthFailOp = desc->StencilFailOp;
+    desc->StencilPassOp = stencil_op_to_d3d11_op(stencilFace.fPassOp);
+    desc->StencilFunc = stencil_test_to_d3d11_func(stencilFace.fTest);
+}
+
+static void fill_in_depth_stencil_state(const GrProgramInfo& programInfo,
+                                        D3D11_DEPTH_STENCIL_DESC* dsDesc) {
+    GrStencilSettings stencilSettings = programInfo.nonGLStencilSettings();
+    GrSurfaceOrigin origin = programInfo.origin();
+
+    dsDesc->DepthEnable = false;
+    dsDesc->DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ZERO;
+    dsDesc->DepthFunc = D3D11_COMPARISON_NEVER;
+    dsDesc->StencilEnable = !stencilSettings.isDisabled();
+    if (!stencilSettings.isDisabled()) {
+        if (stencilSettings.isTwoSided()) {
+            const auto& frontFace = stencilSettings.postOriginCCWFace(origin);
+            const auto& backFace = stencilSettings.postOriginCWFace(origin);
+
+            SkASSERT(frontFace.fTestMask == backFace.fTestMask);
+            SkASSERT(frontFace.fWriteMask == backFace.fWriteMask);
+            dsDesc->StencilReadMask = frontFace.fTestMask;
+            dsDesc->StencilWriteMask = frontFace.fWriteMask;
+
+            setup_stencilop_desc(&dsDesc->FrontFace, frontFace);
+            setup_stencilop_desc(&dsDesc->BackFace, backFace);
+        } else {
+            dsDesc->StencilReadMask = stencilSettings.singleSidedFace().fTestMask;
+            dsDesc->StencilWriteMask = stencilSettings.singleSidedFace().fWriteMask;
+            setup_stencilop_desc(&dsDesc->FrontFace, stencilSettings.singleSidedFace());
+            dsDesc->BackFace = dsDesc->FrontFace;
+        }
+    }
+}
+
+static constexpr SkFourByteTag kHLSL_Tag = SkSetFourByteTag('H', 'L', 'S', 'L');
+static constexpr SkFourByteTag kSKSL_Tag = SkSetFourByteTag('S', 'K', 'S', 'L');
+
+std::unique_ptr<GrD3D11Program> GrD3D11ProgramBuilder::finalize() {
+    TRACE_EVENT0("skia.shaders", TRACE_FUNC);
+
+    this->finalizeShaders();
+
+    SkSL::ProgramSettings settings;
+    settings.fSharpenTextures = 
+        this->gpu()->getContext()->priv().options().fSharpenMipmappedTextures;
+    settings.fRTFlipOffset = fUniformHandler.getRTFlipOffset();
+    settings.fRTFlipBinding = 0;
+    settings.fRTFlipSet = 0;
+
+    sk_sp<SkData> cached;
+    SkReadBuffer reader;
+    SkFourByteTag shaderType = 0;
+    auto persistentCache = fGpu->getContext()->priv().getPersistentCache();
+    if (persistentCache) {
+        // Shear off the D3D-specific portion of the Desc to get the persistent key. We only cache
+        // shader code, not entire pipelines.
+        sk_sp<SkData> key =
+                SkData::MakeWithoutCopy(this->desc().asKey(), this->desc().initialKeyLength());
+        cached = persistentCache->load(*key);
+        if (cached) {
+            reader.setMemory(cached->data(), cached->size());
+            shaderType = GrPersistentCacheUtils::GetType(&reader);
+        }
+    }
+
+    const GrGeometryProcessor& geomProc = this->geometryProcessor();
+    gr_cp<ID3DBlob> shaders[kGrShaderTypeCount];
+
+    if (kHLSL_Tag == shaderType && this->loadHLSLFromCache(&reader, shaders)) {
+        // We successfully loaded and compiled HLSL
+    } else {
+        SkSL::Program::Interface intfs[kGrShaderTypeCount];
+        std::string* sksl[kGrShaderTypeCount] = {
+            &fVS.fCompilerString,
+            &fFS.fCompilerString,
+        };
+        std::string cached_sksl[kGrShaderTypeCount];
+        std::string hlsl[kGrShaderTypeCount];
+
+        if (kSKSL_Tag == shaderType) {
+            if (GrPersistentCacheUtils::UnpackCachedShaders(&reader, cached_sksl, intfs,
+                                                            kGrShaderTypeCount)) {
+                for (int i = 0; i < kGrShaderTypeCount; ++i) {
+                    sksl[i] = &cached_sksl[i];
+                }
+            }
+        }
+
+        auto compile = [&](SkSL::ProgramKind kind, GrShaderType shaderType) {
+            shaders[shaderType] = this->compileD3D11Program(kind, *sksl[shaderType], settings,
+                                                          &intfs[shaderType], &hlsl[shaderType]);
+            return shaders[shaderType].get();
+        };
+
+        if (!compile(SkSL::ProgramKind::kVertex, kVertex_GrShaderType) ||
+            !compile(SkSL::ProgramKind::kFragment, kFragment_GrShaderType)) {
+            return nullptr;
+        }
+
+        if (persistentCache && !cached) {
+            const bool cacheSkSL = fGpu->getContext()->priv().options().fShaderCacheStrategy ==
+                                   GrContextOptions::ShaderCacheStrategy::kSkSL;
+            if (cacheSkSL) {
+                // Replace the HLSL with formatted SkSL to be cached. This looks odd, but this is
+                // the last time we're going to use these strings, so it's safe.
+                for (int i = 0; i < kGrShaderTypeCount; ++i) {
+                    hlsl[i] = SkShaderUtils::PrettyPrint(*sksl[i]);
+                }
+            }
+            sk_sp<SkData> key =
+                    SkData::MakeWithoutCopy(this->desc().asKey(), this->desc().initialKeyLength());
+            SkString description = GrProgramDesc::Describe(fProgramInfo, *this->caps());
+            sk_sp<SkData> data = GrPersistentCacheUtils::PackCachedShaders(
+                    cacheSkSL ? kSKSL_Tag : kHLSL_Tag, hlsl, intfs, kGrShaderTypeCount);
+            persistentCache->store(*key, *data, description);
+        }
+    }
+
+    HRESULT hr;
+
+    gr_cp<ID3D11VertexShader> vertexShader;
+    gr_cp<ID3D11PixelShader> pixelShader;
+    gr_cp<ID3D11InputLayout> inputLayout;
+
+    hr = fGpu->device()->CreateVertexShader(shaders[kVertex_GrShaderType]->GetBufferPointer(),
+                                       shaders[kVertex_GrShaderType]->GetBufferSize(),
+                                       nullptr,
+                                       &vertexShader);
+    GR_D3D_CALL_ERRCHECK(hr);
+
+    hr = fGpu->device()->CreatePixelShader(shaders[kFragment_GrShaderType]->GetBufferPointer(),
+                                      shaders[kFragment_GrShaderType]->GetBufferSize(),
+                                      nullptr,
+                                      &pixelShader);
+    GR_D3D_CALL_ERRCHECK(hr);
+
+    unsigned int totalAttributeCnt = fProgramInfo.geomProc().numVertexAttributes() +
+                                     fProgramInfo.geomProc().numInstanceAttributes();
+    skia_private::AutoSTArray<4, D3D11_INPUT_ELEMENT_DESC> inputElements(totalAttributeCnt);
+    setup_vertex_input_layout(fProgramInfo.geomProc(), inputElements.get());
+
+    hr = fGpu->device()->CreateInputLayout(inputElements.data(),
+                                      inputElements.size(),
+                                      shaders[kVertex_GrShaderType]->GetBufferPointer(),
+                                      shaders[kVertex_GrShaderType]->GetBufferSize(),
+                                      &inputLayout);
+    GR_D3D_CALL_ERRCHECK(hr);
+
+    gr_cp<ID3D11BlendState> blendState;
+    gr_cp<ID3D11RasterizerState> rasterizerState;
+    gr_cp<ID3D11DepthStencilState> depthStencilState;
+
+    D3D11_BLEND_DESC blendDesc;
+    fill_in_blend_state(fProgramInfo.pipeline(), &blendDesc);
+    hr = fGpu->device()->CreateBlendState(&blendDesc, &blendState);
+    GR_D3D_CALL_ERRCHECK(hr);
+
+    D3D11_RASTERIZER_DESC rasterizer;
+    fill_in_rasterizer_state(
+            fProgramInfo.pipeline(), fProgramInfo.numSamples() > 1, fGpu->caps(), &rasterizer);
+    hr = fGpu->device()->CreateRasterizerState(&rasterizer, &rasterizerState);
+    GR_D3D_CALL_ERRCHECK(hr);
+
+    D3D11_DEPTH_STENCIL_DESC dsDesc;
+    fill_in_depth_stencil_state(fProgramInfo, &dsDesc);
+    hr = fGpu->device()->CreateDepthStencilState(&dsDesc, &depthStencilState);
+    GR_D3D_CALL_ERRCHECK(hr);
+
+    return std::unique_ptr<GrD3D11Program>(
+            new GrD3D11Program(std::move(vertexShader),
+                            std::move(pixelShader),
+                            std::move(inputLayout),
+                            std::move(blendState),
+                            std::move(rasterizerState),
+                            std::move(depthStencilState),
+                            fUniformHandles,
+                            fUniformHandler.fUniforms,
+                            fUniformHandler.fCurrentUBOOffset,
+                            fUniformHandler.fSamplers.count(),
+                            std::move(fGPImpl),
+                            std::move(fXPImpl),
+                            std::move(fFPImpls),
+                            geomProc.vertexStride(),
+                            geomProc.instanceStride()));
+}
diff --git a/src/gpu/ganesh/d3d11/GrD3D11ProgramBuilder.h b/src/gpu/ganesh/d3d11/GrD3D11ProgramBuilder.h
new file mode 100644
index 0000000000..5ecd849270
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11ProgramBuilder.h
@@ -0,0 +1,161 @@
+/*
+ * Copyright 2020 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef GrD3DPipelineStateBuilder_DEFINED
+#define GrD3DPipelineStateBuilder_DEFINED
+
+#include "src/gpu/SkSLToBackend.h"
+#include "src/gpu/ganesh/GrPipeline.h"
+#include "src/gpu/ganesh/GrSPIRVUniformHandler.h"
+#include "src/gpu/ganesh/GrSPIRVVaryingHandler.h"
+#include "src/gpu/ganesh/glsl/GrGLSLProgramBuilder.h"
+#include "src/sksl/codegen/SkSLHLSLCodeGenerator.h"
+#include "src/sksl/ir/SkSLProgram.h"
+
+#include "include/gpu/ganesh/d3d11/GrD3D11Types.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11UniformDataManager.h"
+
+class GrProgramDesc;
+class GrD3D11Gpu;
+class GrVkRenderPass;
+class GrD3D11RenderTarget;
+
+struct GrD3D11Program : public SkRefCnt {
+    typedef GrSPIRVUniformHandler::UniformInfoArray UniformInfoArray;
+
+    GrD3D11Program(gr_cp<ID3D11VertexShader> vertexShader,
+                   gr_cp<ID3D11PixelShader> pixelShader,
+                   gr_cp<ID3D11InputLayout> inputLayout,
+                   gr_cp<ID3D11BlendState> blendState,
+                   gr_cp<ID3D11RasterizerState> rasterizerState,
+                   gr_cp<ID3D11DepthStencilState> depthStencilState,
+                   const GrGLSLBuiltinUniformHandles& builtinUniformHandles,
+                   const UniformInfoArray& uniforms,
+                   uint32_t uniformSize,
+                   uint32_t numSamplers,
+                   std::unique_ptr<GrGeometryProcessor::ProgramImpl> gpImpl,
+                   std::unique_ptr<GrXferProcessor::ProgramImpl> xpImpl,
+                   std::vector<std::unique_ptr<GrFragmentProcessor::ProgramImpl>> fpImpls,
+                   size_t vertexStride,
+                   size_t instanceStride);
+
+    // We can only cache non dirty uniform values until we submit a command list. After that, the
+    // next frame will get a completely different uniform buffer and/or offset into the buffer. Thus
+    // we need a way to mark them all as dirty during submit.
+    void markUniformsDirty() { fDataManager.markDirty(); }
+
+    void setAndBindConstants(GrD3D11Gpu*, const GrRenderTarget*, const GrProgramInfo&);
+
+    void setAndBindTextures(GrD3D11Gpu*,
+                            const GrGeometryProcessor&,
+                            const GrSurfaceProxy* const geomProcTextures[],
+                            const GrPipeline&);
+
+    void setBlendState(GrD3D11Gpu* gpu, const GrProgramInfo& programInfo);
+    void setDepthStencilState(GrD3D11Gpu* gpu, const GrProgramInfo& programInfo);
+    void setRasterizerState(GrD3D11Gpu* gpu, const GrProgramInfo& programInfo);
+
+    /**
+     * We use the RT's size and origin to adjust from Skia device space to d3d normalized device
+     * space and to make device space positions have the correct origin for processors that require
+     * them.
+     */
+    struct RenderTargetState {
+        SkISize fRenderTargetSize;
+        GrSurfaceOrigin fRenderTargetOrigin;
+
+        RenderTargetState() { this->invalidate(); }
+        void invalidate() {
+            fRenderTargetSize.fWidth = -1;
+            fRenderTargetSize.fHeight = -1;
+            fRenderTargetOrigin = (GrSurfaceOrigin)-1;
+        }
+    };
+
+    // Helper for setData() that sets the view matrix and loads the render target height uniform
+    void setRenderTargetState(const GrRenderTarget*, GrSurfaceOrigin);
+
+    unsigned int fNumSamplers;
+    size_t fVertexStride;
+    size_t fInstanceStride;
+
+    // Tracks the current render target uniforms stored in the vertex buffer.
+    RenderTargetState fRenderTargetState;
+    GrGLSLBuiltinUniformHandles fBuiltinUniformHandles;
+
+    GrD3D11UniformDataManager fDataManager;
+
+    // Processors in the GrD3DPipelineState
+    std::unique_ptr<GrGeometryProcessor::ProgramImpl> fGPImpl;
+    std::unique_ptr<GrXferProcessor::ProgramImpl> fXPImpl;
+    std::vector<std::unique_ptr<GrFragmentProcessor::ProgramImpl>> fFPImpls;
+
+    gr_cp<ID3D11VertexShader> fVertexShader;
+    gr_cp<ID3D11PixelShader> fPixelShader;
+    gr_cp<ID3D11InputLayout> fInputLayout;
+    gr_cp<ID3D11BlendState> fBlendState;
+    gr_cp<ID3D11RasterizerState> fRasterizerState;
+    gr_cp<ID3D11DepthStencilState> fDepthStencilState;
+};
+
+class GrD3D11ProgramBuilder : public GrGLSLProgramBuilder {
+public:
+    static std::unique_ptr<GrD3D11Program> MakeD3D11Program(GrD3D11Gpu*,
+                                                                const GrProgramDesc&,
+                                                                const GrProgramInfo&);
+
+
+    const GrCaps* caps() const override;
+
+    GrD3D11Gpu* gpu() const { return fGpu; }
+
+    void finalizeFragmentSecondaryColor(GrShaderVar& outputColor) override;
+
+private:
+    GrD3D11ProgramBuilder(GrD3D11Gpu*,
+                          const GrProgramDesc&,
+                              const GrProgramInfo&);
+
+    std::unique_ptr<GrD3D11Program> finalize();
+
+    bool loadHLSLFromCache(SkReadBuffer* reader, gr_cp<ID3DBlob> shaders[]);
+
+    gr_cp<ID3DBlob> compileD3D11Program(SkSL::ProgramKind kind,
+                                      const std::string& sksl,
+                                      const SkSL::ProgramSettings& settings,
+                                      SkSL::Program::Interface* outInterface,
+                                      std::string* outHLSL);
+
+    GrGLSLUniformHandler* uniformHandler() override { return &fUniformHandler; }
+    const GrGLSLUniformHandler* uniformHandler() const override { return &fUniformHandler; }
+    GrGLSLVaryingHandler* varyingHandler() override { return &fVaryingHandler; }
+
+    GrD3D11Gpu* fGpu;
+    GrSPIRVVaryingHandler fVaryingHandler;
+    GrSPIRVUniformHandler fUniformHandler;
+
+    using INHERITED = GrGLSLProgramBuilder;
+};
+
+namespace skgpu {
+
+class ShaderErrorHandler;
+
+inline bool SkSLToHLSL(const SkSL::ShaderCaps* caps,
+                       const std::string& sksl,
+                       SkSL::ProgramKind programKind,
+                       const SkSL::ProgramSettings& settings,
+                       std::string* hlsl,
+                       SkSL::ProgramInterface* outInterface,
+                       ShaderErrorHandler* errorHandler) {
+    return SkSLToBackend(caps, &SkSL::ToHLSL, "HLSL",
+                         sksl, programKind, settings, hlsl, outInterface, errorHandler);
+}
+
+}  // namespace skgpu
+
+#endif
diff --git a/src/gpu/ganesh/d3d11/GrD3D11RenderTarget.cpp b/src/gpu/ganesh/d3d11/GrD3D11RenderTarget.cpp
new file mode 100644
index 0000000000..260b244e4b
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11RenderTarget.cpp
@@ -0,0 +1,124 @@
+
+#include "src/gpu/ganesh/d3d11/GrD3D11RenderTarget.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Attachment.h"
+#include "src/gpu/KeyBuilder.h"
+
+// We're virtually derived from GrSurface (via GrRenderTarget) so its
+// constructor must be explicitly called.
+GrD3D11RenderTarget::GrD3D11RenderTarget(GrD3D11Gpu* gpu,
+                                     SkISize dimensions,
+                                     const GrD3D11TextureInfo& info,
+                                     ID3D11RenderTargetView* renderTargetView,
+                                     Wrapped,
+                                     std::string_view label)
+        : GrSurface(gpu, dimensions, info.fProtected, label)
+        , GrRenderTarget(gpu, dimensions, info.fSampleCount, info.fProtected, label)
+        , fColorRenderTargetView(renderTargetView)
+        , fInfo(info) {
+    this->registerWithCacheWrapped(GrWrapCacheable::kNo);
+}
+
+// We're virtually derived from GrSurface (via GrRenderTarget) so its
+// constructor must be explicitly called.
+GrD3D11RenderTarget::GrD3D11RenderTarget(GrD3D11Gpu* gpu,
+                                     SkISize dimensions,
+                                     const GrD3D11TextureInfo& info,
+                                     ID3D11RenderTargetView* renderTargetView,
+                                     std::string_view label)
+        : GrSurface(gpu, dimensions, info.fProtected, label)
+        , GrRenderTarget(gpu, dimensions, info.fSampleCount, info.fProtected, label)
+        , fColorRenderTargetView(renderTargetView) 
+        , fInfo(info) {}
+
+sk_sp<GrD3D11RenderTarget> GrD3D11RenderTarget::MakeWrappedRenderTarget(
+        GrD3D11Gpu* gpu,
+        SkISize dimensions,
+        int sampleCnt,
+        const GrD3D11TextureInfo& info) {
+    SkASSERT(info.fTexture.get());
+    SkASSERT(info.fLevelCount == 1);
+    SkASSERT(sampleCnt >= 1 && info.fSampleCount >= 1);
+
+    int wrappedTextureSampleCnt = static_cast<int>(info.fSampleCount);
+    if (sampleCnt != wrappedTextureSampleCnt && wrappedTextureSampleCnt != 1) {
+        return nullptr;
+    }
+
+    D3D11_RENDER_TARGET_VIEW_DESC viewDesc;
+    viewDesc.Format = info.fFormat;
+    viewDesc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2D;
+    viewDesc.Texture2D.MipSlice = 0;
+
+    ID3D11RenderTargetView* renderTargetView = nullptr;
+    auto hr = gpu->device()->CreateRenderTargetView(info.fTexture.get(), &viewDesc, &renderTargetView);
+    GR_D3D_CALL_ERRCHECK(hr);
+
+    // create msaa surface if necessary
+    GrD3D11RenderTarget* d3d11RT;
+    d3d11RT = new GrD3D11RenderTarget(gpu,
+                                      dimensions,
+                                      info,
+                                      renderTargetView,
+                                      kWrapped,
+                                      /*label=*/"MakeWrappedRenderTarget");
+
+    return sk_sp<GrD3D11RenderTarget>(d3d11RT);
+}
+
+GrD3D11RenderTarget::~GrD3D11RenderTarget() {
+}
+
+void GrD3D11RenderTarget::releaseInternalObjects() {
+    GrSafeComRelease(fColorRenderTargetView);
+}
+
+void GrD3D11RenderTarget::onRelease() {
+    this->releaseInternalObjects();
+    fInfo.fTexture.reset();
+    GrRenderTarget::onRelease();
+}
+
+void GrD3D11RenderTarget::onAbandon() {
+    this->releaseInternalObjects();
+    fInfo.fTexture.reset();
+    GrRenderTarget::onAbandon();
+}
+
+GrBackendRenderTarget GrD3D11RenderTarget::getBackendRenderTarget() const {
+    sk_sp<GrD3DResourceState> state;
+    return GrBackendRenderTarget(this->width(), this->height(), fInfo.toD3D12Info(), state);
+}
+
+GrD3D11Gpu* GrD3D11RenderTarget::getD3D11Gpu() const {
+    SkASSERT(!this->wasDestroyed());
+    return static_cast<GrD3D11Gpu*>(this->getGpu());
+}
+
+DXGI_FORMAT GrD3D11RenderTarget::stencilDxgiFormat() const {
+    if (auto stencil = this->getStencilAttachment()) {
+        auto d3dStencil = static_cast<GrD3D11Attachment*>(stencil);
+        return d3dStencil->dxgiFormat();
+    }
+    return DXGI_FORMAT_UNKNOWN;
+}
+
+void GrD3D11RenderTarget::genKey(skgpu::KeyBuilder* b) const {
+    b->add32(fInfo.fFormat);
+    b->add32(this->numSamples());
+    b->add32(this->stencilDxgiFormat());
+#ifdef SK_DEBUG
+    if (const GrAttachment* stencil = this->getStencilAttachment()) {
+        SkASSERT(stencil->numSamples() == this->numSamples());
+    }
+#endif
+    b->add32(DXGI_STANDARD_MULTISAMPLE_QUALITY_PATTERN /*this->sampleQualityPattern()*/);
+}
+
+void GrD3D11RenderTarget::onSetLabel() {
+    SkASSERT(this->d3d11Resource());
+    if (!this->getLabel().empty()) {
+        const std::string label = "_Skia_" + this->getLabel();
+        this->d3d11Resource()->SetPrivateData(
+                WKPDID_D3DDebugObjectName, label.size(), label.c_str());
+    }
+}
diff --git a/src/gpu/ganesh/d3d11/GrD3D11RenderTarget.h b/src/gpu/ganesh/d3d11/GrD3D11RenderTarget.h
new file mode 100644
index 0000000000..7e136740e0
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11RenderTarget.h
@@ -0,0 +1,89 @@
+#pragma once
+
+#include "src/gpu/ganesh/GrRenderTarget.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Gpu.h"
+
+class GrD3D11RenderTarget : public GrRenderTarget {
+public:
+    static sk_sp<GrD3D11RenderTarget> MakeWrappedRenderTarget(GrD3D11Gpu*,
+                                                            SkISize,
+                                                            int sampleCnt,
+                                                            const GrD3D11TextureInfo&);
+
+    ~GrD3D11RenderTarget() override;
+
+    GrBackendFormat backendFormat() const override { return fInfo.getBackendFormat(); }
+
+    bool canAttemptStencilAttachment(bool useMSAASurface) const override {
+        SkASSERT(useMSAASurface == (this->numSamples() > 1));
+        return true;
+    }
+
+    GrBackendRenderTarget getBackendRenderTarget() const override;
+
+    ID3D11RenderTargetView* colorRenderTargetView() {
+        return fColorRenderTargetView;
+    }
+
+    DXGI_FORMAT stencilDxgiFormat() const;
+
+    // Key used for the program desc
+    void genKey(skgpu::KeyBuilder* b) const;
+
+    ID3D11Texture2D* d3d11Resource() const {
+        return fInfo.fTexture.get();
+    }
+    DXGI_FORMAT dxgiFormat() const { return fInfo.fFormat; }
+
+    const GrD3D11TextureInfo& getInfo() const { 
+        return fInfo;
+    }
+
+protected:
+    GrD3D11RenderTarget(GrD3D11Gpu* gpu,
+                      SkISize dimensions,
+                      const GrD3D11TextureInfo& info,
+                      ID3D11RenderTargetView* renderTargetView,
+                      std::string_view label);
+
+    void onAbandon() override;
+    void onRelease() override;
+
+    // This accounts for the texture's memory and any MSAA renderbuffer's memory.
+    size_t onGpuMemorySize() const override {
+        int numColorSamples = this->numSamples();
+        if (numColorSamples > 1) {
+            // Add one to account for the resolved VkImage.
+            numColorSamples += 1;
+        }
+        return GrSurface::ComputeSize(
+                this->backendFormat(), this->dimensions(), numColorSamples, skgpu::Mipmapped::kNo);
+    }
+
+    void onSetLabel() override;
+
+private:
+    // Extra param to disambiguate from constructor used by subclasses.
+    enum Wrapped { kWrapped };
+    GrD3D11RenderTarget(GrD3D11Gpu* gpu,
+                      SkISize dimensions,
+                      const GrD3D11TextureInfo& info,
+                      ID3D11RenderTargetView* renderTargetView,
+                      Wrapped,
+                      std::string_view label);
+
+    GrD3D11Gpu* getD3D11Gpu() const;
+
+    bool completeStencilAttachment(GrAttachment* stencil, bool useMSAASurface) override {
+        SkASSERT(useMSAASurface == (this->numSamples() > 1));
+        return true;
+    }
+
+    void releaseInternalObjects();
+
+    ID3D11RenderTargetView* fColorRenderTargetView = nullptr;
+
+    GrD3D11TextureInfo fInfo;
+
+    using INHERITED = GrRenderTarget;
+};
diff --git a/src/gpu/ganesh/d3d11/GrD3D11RenderTask.h b/src/gpu/ganesh/d3d11/GrD3D11RenderTask.h
new file mode 100644
index 0000000000..1911a99a36
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11RenderTask.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef GrD3D11RenderTask_DEFINED
+#define GrD3D11RenderTask_DEFINED
+
+#include "src/gpu/ganesh/GrRenderTask.h"
+
+class GrD3D11RenderTask final : public GrRenderTask {
+public:
+    GrD3D11RenderTask() : GrRenderTask() {
+        // D3D11 tasks are never "owned" by a drawmgr in the first place.
+        this->setFlag(kDisowned_Flag);
+    }
+
+    void addTarget(sk_sp<GrSurfaceProxy> proxy) { fTargets.push_back(std::move(proxy)); }
+    void addDependency(GrRenderTask* dep) { fDependencies.push_back(dep); }
+    void addUsed(sk_sp<GrSurfaceProxy> proxy) { fUsed.push_back(std::move(proxy)); }
+
+    // Overrides.
+#ifdef SK_DEBUG
+    void visitProxies_debugOnly(const GrVisitProxyFunc&) const override { return; }
+#endif
+    void gatherProxyIntervals(GrResourceAllocator*) const override {}
+    ExpectedOutcome onMakeClosed(GrRecordingContext*, SkIRect*) override { SkUNREACHABLE; }
+    bool onIsUsed(GrSurfaceProxy* proxy) const override {
+        for (const auto& entry : fUsed) {
+            if (entry.get() == proxy) {
+                return true;
+            }
+        }
+        return false;
+    }
+    bool onExecute(GrOpFlushState*) override { return true; }
+
+#if GR_TEST_UTILS
+    const char* name() const final { return "D3D11"; }
+#endif
+
+private:
+    SkTArray<sk_sp<GrSurfaceProxy>> fUsed;
+};
+
+#endif
diff --git a/src/gpu/ganesh/d3d11/GrD3D11ResourceProvider.cpp b/src/gpu/ganesh/d3d11/GrD3D11ResourceProvider.cpp
new file mode 100644
index 0000000000..1a4cf870b3
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11ResourceProvider.cpp
@@ -0,0 +1,193 @@
+/*
+ * Copyright 2020 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "src/gpu/ganesh/d3d11/GrD3D11ResourceProvider.h"
+
+#include "include/gpu/ganesh/GrContextOptions.h"
+#include "include/gpu/ganesh/GrDirectContext.h"
+#include "src/gpu/ganesh/GrDirectContextPriv.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Gpu.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11RenderTarget.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11ProgramBuilder.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Buffer.h"
+
+GrD3D11ResourceProvider::GrD3D11ResourceProvider(GrD3D11Gpu* gpu)
+        : fGpu(gpu)
+        , fProgramCache(new ProgramCache(gpu))
+{
+}
+
+void GrD3D11ResourceProvider::destroyResources() {
+    for (auto itr = fSamplers.begin(); itr != fSamplers.end(); itr++) {
+        itr->second->Release();
+    }
+    fSamplers.reset();
+
+
+    fProgramCache->release();
+}
+
+static D3D11_TEXTURE_ADDRESS_MODE wrap_mode_to_d3d11_address_mode(GrSamplerState::WrapMode wrapMode) {
+    switch (wrapMode) {
+    case GrSamplerState::WrapMode::kClamp:
+        return D3D11_TEXTURE_ADDRESS_CLAMP;
+    case GrSamplerState::WrapMode::kRepeat:
+        return D3D11_TEXTURE_ADDRESS_WRAP;
+    case GrSamplerState::WrapMode::kMirrorRepeat:
+        return D3D11_TEXTURE_ADDRESS_MIRROR;
+    case GrSamplerState::WrapMode::kClampToBorder:
+        return D3D11_TEXTURE_ADDRESS_BORDER;
+    }
+    SK_ABORT("Unknown wrap mode.");
+}
+
+static D3D11_FILTER d3d11_filter(GrSamplerState sampler) {
+    if (sampler.isAniso()) {
+        return D3D11_FILTER_ANISOTROPIC;
+    }
+    switch (sampler.mipmapMode()) {
+        // When the mode is kNone we disable filtering using maxLOD.
+        case GrSamplerState::MipmapMode::kNone:
+        case GrSamplerState::MipmapMode::kNearest:
+            switch (sampler.filter()) {
+                case GrSamplerState::Filter::kNearest: return D3D11_FILTER_MIN_MAG_MIP_POINT;
+                case GrSamplerState::Filter::kLinear:  return D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT;
+            }
+            SkUNREACHABLE;
+        case GrSamplerState::MipmapMode::kLinear:
+            switch (sampler.filter()) {
+                case GrSamplerState::Filter::kNearest: return D3D11_FILTER_MIN_MAG_POINT_MIP_LINEAR;
+                case GrSamplerState::Filter::kLinear:  return D3D11_FILTER_MIN_MAG_MIP_LINEAR;
+            }
+            SkUNREACHABLE;
+    }
+    SkUNREACHABLE;
+}
+
+ID3D11SamplerState* GrD3D11ResourceProvider::findOrCreateCompatibleSampler(
+        const GrSamplerState& params) {
+    // In D3D anisotropic filtering uses the same field (D3D12_SAMPLER_DESC::Filter) as min/mag/mip
+    // settings and so is not orthogonal to them.
+    uint32_t key = params.asKey(/*anisoIsOrthogonal=*/false);
+    ID3D11SamplerState** samplerPtr = fSamplers.find(key);
+    if (samplerPtr) {
+        return *samplerPtr;
+    }
+
+    D3D11_FILTER filter = d3d11_filter(params);
+    // We disable MIP filtering using maxLOD. Otherwise, we want the max LOD to be unbounded.
+    float maxLOD = params.mipmapped() == skgpu::Mipmapped::kYes ? std::numeric_limits<float>::max()
+                                                           : 0.f;
+    D3D11_TEXTURE_ADDRESS_MODE addressModeU = wrap_mode_to_d3d11_address_mode(params.wrapModeX());
+    D3D11_TEXTURE_ADDRESS_MODE addressModeV = wrap_mode_to_d3d11_address_mode(params.wrapModeY());
+    unsigned int maxAnisotropy = params.maxAniso();
+
+    D3D11_SAMPLER_DESC desc = {};
+    desc.Filter = filter;
+    desc.AddressU = addressModeU;
+    desc.AddressV = addressModeV;
+    desc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
+    desc.MipLODBias = 0;
+    desc.MaxAnisotropy = maxAnisotropy;
+    desc.ComparisonFunc = D3D11_COMPARISON_ALWAYS;
+    // desc.BorderColor initialized to { 0, 0, 0, 0 } by default initializer, above.
+    desc.MinLOD = 0;
+    desc.MaxLOD = maxLOD;
+
+    ID3D11SamplerState* sampler = nullptr;
+    auto hr = fGpu->device()->CreateSamplerState(&desc, &sampler);
+    GR_D3D_CALL_ERRCHECK(hr);
+
+    fSamplers.set(key, sampler);
+    return sampler;
+}
+
+GrD3D11Program* GrD3D11ResourceProvider::findOrCreateProgram(GrD3D11RenderTarget* renderTarget, const GrProgramInfo& info) {
+    return fProgramCache->refProgram(renderTarget, info);
+}
+
+void GrD3D11ResourceProvider::prepForSubmit() {
+}
+
+////////////////////////////////////////////////////////////////////////////////////////////////
+
+#ifdef GR_PROGRAM_CACHE_STATS
+static const bool c_DisplayProgramCache{false};
+#endif
+
+struct GrD3D11ResourceProvider::ProgramCache::Entry {
+    Entry(GrD3D11Gpu* gpu, std::unique_ptr<GrD3D11Program> program)
+            : fGpu(gpu), fProgram(std::move(program)) {}
+
+    GrD3D11Gpu* fGpu;
+    std::unique_ptr<GrD3D11Program> fProgram;
+};
+
+GrD3D11ResourceProvider::ProgramCache::ProgramCache(GrD3D11Gpu* gpu)
+        : fMap(gpu->getContext()->priv().options().fRuntimeProgramCacheSize)
+        , fGpu(gpu)
+#ifdef GR_PIPELINE_STATE_CACHE_STATS
+        , fTotalRequests(0)
+        , fCacheMisses(0)
+#endif
+{
+}
+
+GrD3D11ResourceProvider::ProgramCache::~ProgramCache() {
+    // dump stats
+#ifdef GR_PROGRAM_CACHE_STATS
+    if (c_DisplayProgramCache) {
+        SkDebugf("--- Pipeline State Cache ---\n");
+        SkDebugf("Total requests: %d\n", fTotalRequests);
+        SkDebugf("Cache misses: %d\n", fCacheMisses);
+        SkDebugf("Cache miss %%: %f\n",
+                 (fTotalRequests > 0) ? 100.f * fCacheMisses / fTotalRequests : 0.f);
+        SkDebugf("---------------------\n");
+    }
+#endif
+}
+
+void GrD3D11ResourceProvider::ProgramCache::release() {
+    fMap.reset();
+}
+
+GrD3D11Program* GrD3D11ResourceProvider::ProgramCache::refProgram(GrD3D11RenderTarget* renderTarget, const GrProgramInfo& programInfo) {
+#ifdef GR_PROGRAM_CACHE_STATS
+    ++fTotalRequests;
+#endif
+
+    const GrCaps* caps = fGpu->caps();
+
+    GrProgramDesc desc = caps->makeDesc(renderTarget, programInfo);
+    if (!desc.isValid()) {
+        GrCapsDebugf(fGpu->caps(), "Failed to build mtl program descriptor!\n");
+        return nullptr;
+    }
+
+    std::unique_ptr<Entry>* entry = fMap.find(desc);
+    if (!entry) {
+#ifdef GR_PROGRAM_CACHE_STATS
+        ++fCacheMisses;
+#endif
+        std::unique_ptr<GrD3D11Program> program =
+                GrD3D11ProgramBuilder::MakeD3D11Program(fGpu, desc, programInfo);
+        if (!program) {
+            return nullptr;
+        }
+        entry = fMap.insert(desc, std::unique_ptr<Entry>(
+                new Entry(fGpu, std::move(program))));
+        return ((*entry)->fProgram).get();
+    }
+    return ((*entry)->fProgram).get();
+}
+
+void GrD3D11ResourceProvider::ProgramCache::markProgramUniformsDirty() {
+    fMap.foreach ([](const GrProgramDesc*, std::unique_ptr<Entry>* entry) {
+        (*entry)->fProgram->markUniformsDirty();
+    });
+}
+
diff --git a/src/gpu/ganesh/d3d11/GrD3D11ResourceProvider.h b/src/gpu/ganesh/d3d11/GrD3D11ResourceProvider.h
new file mode 100644
index 0000000000..5e3486b79a
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11ResourceProvider.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2020 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef GrD3D11ResourceProvider_DEFINED
+#define GrD3D11ResourceProvider_DEFINED
+
+#include "include/gpu/ganesh/d3d11/GrD3D11Types.h"
+#include "include/private/base/SkTArray.h"
+#include "src/core/SkTHash.h"
+#include "src/core/SkLRUCache.h"
+#include "src/gpu/ganesh/GrProgramDesc.h"
+#include "src/gpu/ganesh/GrRingBuffer.h"
+
+#include <memory>
+
+class GrD3D11Gpu;
+class GrSamplerState;
+struct GrD3D11Program;
+class GrD3D11RenderTarget;
+class GrD3D11Buffer;
+
+class GrD3D11ResourceProvider {
+public:
+    GrD3D11ResourceProvider(GrD3D11Gpu*);
+
+    void destroyResources();
+
+    ID3D11SamplerState* findOrCreateCompatibleSampler(const GrSamplerState& params);
+
+    GrD3D11Program* findOrCreateProgram(GrD3D11RenderTarget* renderTarget, const GrProgramInfo&);
+
+    void prepForSubmit();
+
+    void markProgramUniformsDirty() { fProgramCache->markProgramUniformsDirty(); }
+
+#if defined(GPU_TEST_UTILS)
+    void resetShaderCacheForTesting() const { fProgramCache->release(); }
+#endif
+
+private:
+#ifdef SK_DEBUG
+#define GR_PROGRAM_CACHE_STATS
+#endif
+
+    class ProgramCache : public ::SkNoncopyable {
+    public:
+        ProgramCache(GrD3D11Gpu* gpu);
+        ~ProgramCache();
+
+        void release();
+        GrD3D11Program* refProgram(GrD3D11RenderTarget* renderTarget, const GrProgramInfo&);
+
+        void markProgramUniformsDirty();
+
+    private:
+        struct Entry;
+
+        struct DescHash {
+            uint32_t operator()(const GrProgramDesc& desc) const {
+                return SkChecksum::Hash32(desc.asKey(), desc.keyLength());
+            }
+        };
+
+        SkLRUCache<const GrProgramDesc, std::unique_ptr<Entry>, DescHash> fMap;
+
+        GrD3D11Gpu* fGpu;
+
+#ifdef GR_PROGRAM_CACHE_STATS
+        int fTotalRequests;
+        int fCacheMisses;
+#endif
+    };
+
+    GrD3D11Gpu* fGpu;
+
+    std::unique_ptr<ProgramCache> fProgramCache;
+    skia_private::THashMap<uint32_t, ID3D11SamplerState*> fSamplers;
+};
+
+#endif
diff --git a/src/gpu/ganesh/d3d11/GrD3D11SurfaceProxy.h b/src/gpu/ganesh/d3d11/GrD3D11SurfaceProxy.h
new file mode 100644
index 0000000000..a86aab67a7
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11SurfaceProxy.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef GrD3D11SurfaceProxy_DEFINED
+#define GrD3D11SurfaceProxy_DEFINED
+
+#include "src/gpu/ganesh/GrSurfaceProxy.h"
+
+class GrD3D11SurfaceProxy : public GrSurfaceProxy {
+public:
+    GrD3D11SurfaceProxy(SkString name, std::string_view label)
+            : GrSurfaceProxy(GrBackendFormat::MakeDxgi(DXGI_FORMAT_R8G8B8A8_UNORM),
+                             SkISize::Make(1, 1),
+                             SkBackingFit::kExact,
+                             SkBudgeted::kNo,
+                             GrProtected::kNo,
+                             GrInternalSurfaceFlags::kNone,
+                             UseAllocator::kNo,
+                             label) {
+        SkDEBUGCODE(this->setDebugName(std::move(name)));
+    }
+
+    bool instantiate(GrResourceProvider*) override { return false; }
+    SkDEBUGCODE(void onValidateSurface(const GrSurface*) override {} )
+    size_t onUninstantiatedGpuMemorySize() const override { return 0; }
+
+protected:
+    sk_sp<GrSurface> createSurface(GrResourceProvider*) const override { return nullptr; }
+
+private:
+    LazySurfaceDesc callbackDesc() const override { SkUNREACHABLE; }
+};
+
+#endif
diff --git a/src/gpu/ganesh/d3d11/GrD3D11Texture.cpp b/src/gpu/ganesh/d3d11/GrD3D11Texture.cpp
new file mode 100644
index 0000000000..d85e4d5d72
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11Texture.cpp
@@ -0,0 +1,159 @@
+
+#include "src/gpu/ganesh/d3d11/GrD3D11Texture.h"
+
+GrD3D11Texture::GrD3D11Texture(GrD3D11Gpu* gpu,
+                           skgpu::Budgeted budgeted,
+                           SkISize dimensions,
+                           const GrD3D11TextureInfo& info,
+                           ID3D11ShaderResourceView* shaderResourceView,
+                           GrMipmapStatus mipmapStatus,
+                           std::string_view label)
+        : GrSurface(gpu, dimensions, info.fProtected, label)
+        , INHERITED(gpu, dimensions, info.fProtected, GrTextureType::k2D, mipmapStatus, label)
+        , fShaderResourceView(shaderResourceView) 
+        , fInfo(info) {
+    SkASSERT((GrMipmapStatus::kNotAllocated == mipmapStatus) == (1 == info.fLevelCount));
+    this->registerWithCache(budgeted);
+    if (GrDxgiFormatIsCompressed(info.fFormat)) {
+        this->setReadOnly();
+    }
+}
+
+GrD3D11Texture::GrD3D11Texture(GrD3D11Gpu* gpu,
+                           SkISize dimensions,
+                           const GrD3D11TextureInfo& info,
+                           ID3D11ShaderResourceView* shaderResourceView,
+                           GrMipmapStatus mipmapStatus,
+                           GrWrapCacheable cacheable,
+                           GrIOType ioType,
+                           std::string_view label)
+        : GrSurface(gpu, dimensions, info.fProtected, label)
+        , INHERITED(gpu, dimensions, info.fProtected, GrTextureType::k2D, mipmapStatus, label)
+        , fShaderResourceView(shaderResourceView)
+        , fInfo(info) {
+    SkASSERT((GrMipmapStatus::kNotAllocated == mipmapStatus) == (1 == info.fLevelCount));
+    if (ioType == kRead_GrIOType) {
+        this->setReadOnly();
+    }
+    this->registerWithCacheWrapped(cacheable);
+}
+
+GrD3D11Texture::GrD3D11Texture(GrD3D11Gpu* gpu,
+                           SkISize dimensions,
+                           const GrD3D11TextureInfo& info,
+                           ID3D11ShaderResourceView* shaderResourceView,
+                           GrMipmapStatus mipmapStatus,
+                           std::string_view label)
+        : GrSurface(gpu, dimensions, info.fProtected, label)
+        , INHERITED(gpu, dimensions, info.fProtected, GrTextureType::k2D, mipmapStatus, label)
+        , fShaderResourceView(shaderResourceView) 
+        , fInfo(info) {
+    SkASSERT((GrMipmapStatus::kNotAllocated == mipmapStatus) == (1 == info.fLevelCount));
+}
+
+sk_sp<GrD3D11Texture> GrD3D11Texture::MakeNewTexture(GrD3D11Gpu* gpu,
+                                                 skgpu::Budgeted budgeted,
+                                                 SkISize dimensions,
+                                                 const D3D11_TEXTURE2D_DESC& desc,
+                                                 GrProtected isProtected,
+                                                 GrMipmapStatus mipmapStatus,
+                                                 std::string_view label) {
+
+    GrD3D11TextureInfo info;
+    info.fFormat = desc.Format;
+    info.fLevelCount = desc.MipLevels;
+    info.fProtected = isProtected;
+    info.fSampleCount = desc.SampleDesc.Count;
+
+    HRESULT hr = gpu->device()->CreateTexture2D(&desc, nullptr, &info.fTexture);
+    GR_D3D_CALL_ERRCHECK(hr);
+
+    D3D11_SHADER_RESOURCE_VIEW_DESC viewDesc;
+    viewDesc.Format = desc.Format;
+    viewDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
+    viewDesc.Texture2D.MipLevels = -1;
+    viewDesc.Texture2D.MostDetailedMip = 0;
+
+    ID3D11ShaderResourceView* shaderResourceView = nullptr;
+    hr = gpu->device()->CreateShaderResourceView(
+            info.fTexture.get(), &viewDesc, &shaderResourceView);
+    GR_D3D_CALL_ERRCHECK(hr);
+
+    GrD3D11Texture* tex = new GrD3D11Texture(gpu,
+                                         budgeted,
+                                         dimensions,
+                                         info,
+                                         shaderResourceView,
+                                         mipmapStatus,
+                                         label);
+
+    return sk_sp<GrD3D11Texture>(tex);
+}
+
+sk_sp<GrD3D11Texture> GrD3D11Texture::MakeWrappedTexture(GrD3D11Gpu* gpu,
+                                                     SkISize dimensions,
+                                                     GrWrapCacheable cacheable,
+                                                     GrIOType ioType,
+                                                     const GrD3D11TextureInfo& info) {
+    GrMipmapStatus mipmapStatus =
+            info.fLevelCount > 1 ? GrMipmapStatus::kValid : GrMipmapStatus::kNotAllocated;
+
+    D3D11_SHADER_RESOURCE_VIEW_DESC viewDesc;
+    viewDesc.Format = info.fFormat;
+    viewDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
+    viewDesc.Texture2D.MipLevels = -1;
+    viewDesc.Texture2D.MostDetailedMip = 0;
+
+    ID3D11ShaderResourceView* shaderResourceView = nullptr;
+    auto hr = gpu->device()->CreateShaderResourceView(
+            info.fTexture.get(), &viewDesc, &shaderResourceView);
+    GR_D3D_CALL_ERRCHECK(hr);
+
+    return sk_sp<GrD3D11Texture>(new GrD3D11Texture(gpu,
+                                                dimensions,
+                                                info,
+                                                shaderResourceView,
+                                                mipmapStatus,
+                                                cacheable,
+                                                ioType,
+                                                /*label=*/"D3DWrappedTexture"));
+}
+
+void GrD3D11Texture::onRelease() {
+    GrD3D11Gpu* gpu = this->getD3D11Gpu();
+    GrSafeComRelease(fShaderResourceView);
+    this->releaseResource(gpu);
+
+    INHERITED::onRelease();
+}
+
+void GrD3D11Texture::onAbandon() {
+    GrD3D11Gpu* gpu = this->getD3D11Gpu();
+    GrSafeComRelease(fShaderResourceView);
+    this->releaseResource(gpu);
+
+    INHERITED::onAbandon();
+}
+
+void GrD3D11Texture::releaseResource(GrD3D11Gpu* gpu) {
+    fInfo.fTexture.reset();
+}
+
+GrBackendTexture GrD3D11Texture::getBackendTexture() const {
+    sk_sp<GrD3DResourceState> state;
+    return GrBackendTexture(this->width(), this->height(), fInfo.toD3D12Info(), state);
+}
+
+GrD3D11Gpu* GrD3D11Texture::getD3D11Gpu() const {
+    SkASSERT(!this->wasDestroyed());
+    return static_cast<GrD3D11Gpu*>(this->getGpu());
+}
+
+void GrD3D11Texture::onSetLabel() {
+    SkASSERT(this->d3d11Resource());
+    if (!this->getLabel().empty()) {
+        const std::string label = "_Skia_" + this->getLabel();
+        this->d3d11Resource()->SetPrivateData(
+                WKPDID_D3DDebugObjectName, label.size(), label.c_str());
+    }
+}
diff --git a/src/gpu/ganesh/d3d11/GrD3D11Texture.h b/src/gpu/ganesh/d3d11/GrD3D11Texture.h
new file mode 100644
index 0000000000..e63af4b538
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11Texture.h
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#ifndef GrD3D11Texture_DEFINED
+#define GrD3D11Texture_DEFINED
+
+#include "include/gpu/ganesh/SkImageGanesh.h"
+#include "include/gpu/ganesh/d3d11/GrD3D11Types.h"
+#include "src/gpu/ganesh/GrAttachment.h"
+#include "src/gpu/ganesh/GrTexture.h"
+#include "src/gpu/ganesh/GrBackendUtils.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Gpu.h"
+
+class GrD3D11Texture : public GrTexture {
+public:
+    static sk_sp<GrD3D11Texture> MakeNewTexture(GrD3D11Gpu*,
+                                              skgpu::Budgeted,
+                                              SkISize dimensions,
+                                              const D3D11_TEXTURE2D_DESC&,
+                                              GrProtected,
+                                              GrMipmapStatus,
+                                              std::string_view label);
+
+    static sk_sp<GrD3D11Texture> MakeWrappedTexture(GrD3D11Gpu*,
+                                                  SkISize dimensions,
+                                                  GrWrapCacheable,
+                                                  GrIOType,
+                                                  const GrD3D11TextureInfo&);
+
+    ~GrD3D11Texture() override {}
+
+    GrBackendTexture getBackendTexture() const override;
+
+    GrBackendFormat backendFormat() const override {
+        return fInfo.getBackendFormat();
+    }
+
+    ID3D11ShaderResourceView* shaderResourceView() { return fShaderResourceView; }
+
+    void textureParamsModified() override {}
+
+    DXGI_FORMAT dxgiFormat() const { return fInfo.fFormat; }
+
+    ID3D11Texture2D* d3d11Resource() const { 
+        return fInfo.fTexture.get();
+    }
+
+    const GrD3D11TextureInfo& getInfo() const { 
+        return fInfo; 
+    }
+
+protected:
+    GrD3D11Texture(GrD3D11Gpu*,
+                 SkISize dimensions,
+                 const GrD3D11TextureInfo&,
+                 ID3D11ShaderResourceView* shaderResourceView,
+                 GrMipmapStatus,
+                 std::string_view label);
+
+    GrD3D11Gpu* getD3D11Gpu() const;
+
+    void onRelease() override;
+    void onAbandon() override;
+
+    void releaseResource(GrD3D11Gpu* gpu);
+
+    bool onStealBackendTexture(GrBackendTexture*, SkImages::BackendTextureReleaseProc*) override {
+        return false;
+    }
+
+    void onSetLabel() override;
+
+private:
+    GrD3D11Texture(GrD3D11Gpu*,
+                 skgpu::Budgeted,
+                 SkISize dimensions,
+                 const GrD3D11TextureInfo&,
+                 ID3D11ShaderResourceView* shaderResourceView,
+                 GrMipmapStatus,
+                 std::string_view label);
+    GrD3D11Texture(GrD3D11Gpu*,
+                 SkISize dimensions,
+                 const GrD3D11TextureInfo&,
+                 ID3D11ShaderResourceView* shaderResourceView,
+                 GrMipmapStatus,
+                 GrWrapCacheable,
+                 GrIOType,
+                 std::string_view label);
+
+    ID3D11ShaderResourceView* fShaderResourceView;
+    GrD3D11TextureInfo fInfo;
+
+    using INHERITED = GrTexture;
+};
+
+#endif
diff --git a/src/gpu/ganesh/d3d11/GrD3D11TextureRenderTarget.cpp b/src/gpu/ganesh/d3d11/GrD3D11TextureRenderTarget.cpp
new file mode 100644
index 0000000000..9e3fb0d11e
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11TextureRenderTarget.cpp
@@ -0,0 +1,149 @@
+
+#include "src/gpu/ganesh/d3d11/GrD3D11TextureRenderTarget.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Gpu.h"
+
+GrD3D11TextureRenderTarget::GrD3D11TextureRenderTarget(
+        GrD3D11Gpu* gpu,
+        skgpu::Budgeted budgeted,
+        SkISize dimensions,
+        const GrD3D11TextureInfo& info,
+        ID3D11ShaderResourceView* shaderResourceView,
+        ID3D11RenderTargetView* renderTargetView,
+        GrMipmapStatus mipmapStatus,
+        std::string_view label)
+        : GrSurface(gpu, dimensions, info.fProtected, label)
+        , GrD3D11Texture(gpu, dimensions, info, shaderResourceView, mipmapStatus, label)
+        , GrD3D11RenderTarget(gpu, dimensions, info, renderTargetView, label) {
+    this->registerWithCache(budgeted);
+}
+
+GrD3D11TextureRenderTarget::GrD3D11TextureRenderTarget(
+        GrD3D11Gpu* gpu,
+        SkISize dimensions,
+        const GrD3D11TextureInfo& info,
+        ID3D11ShaderResourceView* shaderResourceView,
+        ID3D11RenderTargetView* renderTargetView,
+        GrMipmapStatus mipmapStatus,
+        GrWrapCacheable cacheable,
+        std::string_view label)
+        : GrSurface(gpu, dimensions, info.fProtected, label)
+        , GrD3D11Texture(gpu, dimensions, info, shaderResourceView, mipmapStatus, label)
+        , GrD3D11RenderTarget(gpu, dimensions, info, renderTargetView, label) {
+    this->registerWithCacheWrapped(cacheable);
+}
+
+sk_sp<GrD3D11TextureRenderTarget> GrD3D11TextureRenderTarget::MakeNewTextureRenderTarget(
+        GrD3D11Gpu* gpu,
+        skgpu::Budgeted budgeted,
+        SkISize dimensions,
+        int sampleCnt,
+        const D3D11_TEXTURE2D_DESC& desc,
+        GrProtected isProtected,
+        GrMipmapStatus mipmapStatus,
+        std::string_view label) {
+
+    GrD3D11TextureInfo info;
+    info.fFormat = desc.Format;
+    info.fLevelCount = desc.MipLevels;
+    info.fProtected = isProtected;
+    info.fSampleCount = desc.SampleDesc.Count;
+
+    HRESULT hr = gpu->device()->CreateTexture2D(&desc, nullptr, &info.fTexture);
+    GR_D3D_CALL_ERRCHECK(hr);
+
+    ID3D11ShaderResourceView* shaderResourceView = nullptr;
+    {
+        D3D11_SHADER_RESOURCE_VIEW_DESC viewDesc;
+        viewDesc.Format = info.fFormat;
+        viewDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
+        viewDesc.Texture2D.MipLevels = -1;
+        viewDesc.Texture2D.MostDetailedMip = 0;
+
+        hr = gpu->device()->CreateShaderResourceView(
+                info.fTexture.get(), &viewDesc, &shaderResourceView);
+        GR_D3D_CALL_ERRCHECK(hr);
+    }
+
+    ID3D11RenderTargetView* renderTargetView = nullptr;
+    {
+        D3D11_RENDER_TARGET_VIEW_DESC viewDesc;
+        viewDesc.Format = info.fFormat;
+        viewDesc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2D;
+        viewDesc.Texture2D.MipSlice = 0;
+
+        hr = gpu->device()->CreateRenderTargetView(
+                info.fTexture.get(), &viewDesc, &renderTargetView);
+        GR_D3D_CALL_ERRCHECK(hr);
+    }
+
+    GrD3D11TextureRenderTarget* trt = new GrD3D11TextureRenderTarget(gpu,
+                                                                    budgeted,
+                                                                    dimensions,
+                                                                    info,
+                                                                    shaderResourceView,
+                                                                    renderTargetView,
+                                                                    mipmapStatus,
+                                                                    label);
+    return sk_sp<GrD3D11TextureRenderTarget>(trt);
+}
+
+sk_sp<GrD3D11TextureRenderTarget> GrD3D11TextureRenderTarget::MakeWrappedTextureRenderTarget(
+        GrD3D11Gpu* gpu,
+        SkISize dimensions,
+        int sampleCnt,
+        GrWrapCacheable cacheable,
+        const GrD3D11TextureInfo& info) {
+
+    GrMipmapStatus mipmapStatus =
+            info.fLevelCount > 1 ? GrMipmapStatus::kDirty : GrMipmapStatus::kNotAllocated;
+
+    HRESULT hr;
+    ID3D11ShaderResourceView* shaderResourceView = nullptr;
+    {
+        D3D11_SHADER_RESOURCE_VIEW_DESC viewDesc;
+        viewDesc.Format = info.fFormat;
+        viewDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
+        viewDesc.Texture2D.MipLevels = -1;
+        viewDesc.Texture2D.MostDetailedMip = 0;
+
+        hr = gpu->device()->CreateShaderResourceView(
+                info.fTexture.get(), &viewDesc, &shaderResourceView);
+        GR_D3D_CALL_ERRCHECK(hr);
+    }
+
+    ID3D11RenderTargetView* renderTargetView = nullptr;
+    {
+        D3D11_RENDER_TARGET_VIEW_DESC viewDesc;
+        viewDesc.Format = info.fFormat;
+        viewDesc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2D;
+        viewDesc.Texture2D.MipSlice = 0;
+
+        hr = gpu->device()->CreateRenderTargetView(
+                info.fTexture.get(), &viewDesc, &renderTargetView);
+        GR_D3D_CALL_ERRCHECK(hr);
+    }
+
+    return sk_sp<GrD3D11TextureRenderTarget>(
+                new GrD3D11TextureRenderTarget(gpu,
+                                             dimensions,
+                                             info,
+                                             shaderResourceView,
+                                             renderTargetView,
+                                             mipmapStatus,
+                                             cacheable,
+                                             /*label=*/"MakeWrappedTextureRenderTarget"));
+}
+
+size_t GrD3D11TextureRenderTarget::onGpuMemorySize() const {
+    int numColorSamples = this->numSamples();
+    if (numColorSamples > 1) {
+        // Add one to account for the resolve VkImage.
+        ++numColorSamples;
+    }
+    return GrSurface::ComputeSize(this->backendFormat(),
+                                  this->dimensions(),
+                                  numColorSamples,  // TODO: this still correct?
+                                  this->mipmapped());
+}
+
+void GrD3D11TextureRenderTarget::onSetLabel() { GrD3D11RenderTarget::onSetLabel(); }
diff --git a/src/gpu/ganesh/d3d11/GrD3D11TextureRenderTarget.h b/src/gpu/ganesh/d3d11/GrD3D11TextureRenderTarget.h
new file mode 100644
index 0000000000..c0a6f7f204
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11TextureRenderTarget.h
@@ -0,0 +1,79 @@
+
+#pragma once
+
+#include "src/gpu/ganesh/d3d11/GrD3D11Texture.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11RenderTarget.h"
+
+class GrD3D11Gpu;
+
+#ifdef SK_BUILD_FOR_WIN
+// Windows gives bogus warnings about inheriting asTexture/asRenderTarget via dominance.
+#pragma warning(push)
+#pragma warning(disable : 4250)
+#endif
+
+class GrD3D11TextureRenderTarget : public GrD3D11Texture, public GrD3D11RenderTarget {
+public:
+    static sk_sp<GrD3D11TextureRenderTarget> MakeNewTextureRenderTarget(GrD3D11Gpu*,
+                                                                      skgpu::Budgeted,
+                                                                      SkISize dimensions,
+                                                                      int sampleCnt,
+                                                                      const D3D11_TEXTURE2D_DESC&,
+                                                                      GrProtected isProtected,
+                                                                      GrMipmapStatus,
+                                                                      std::string_view label);
+
+    static sk_sp<GrD3D11TextureRenderTarget> MakeWrappedTextureRenderTarget(
+            GrD3D11Gpu*,
+            SkISize dimensions,
+            int sampleCnt,
+            GrWrapCacheable,
+            const GrD3D11TextureInfo&);
+
+    GrBackendFormat backendFormat() const override {
+        return GrD3D11RenderTarget::backendFormat();
+    }
+
+protected:
+    void onAbandon() override {
+        // In order to correctly handle calling texture idle procs, GrD3DTexture must go first.
+        GrD3D11Texture::onAbandon();
+        GrD3D11RenderTarget::onAbandon();
+    }
+
+    void onRelease() override {
+        // In order to correctly handle calling texture idle procs, GrD3DTexture must go first.
+        GrD3D11Texture::onRelease();
+        GrD3D11RenderTarget::onRelease();
+    }
+
+private:
+    // non-MSAA, not-wrapped
+    GrD3D11TextureRenderTarget(GrD3D11Gpu* gpu,
+                             skgpu::Budgeted budgeted,
+                             SkISize dimensions,
+                             const GrD3D11TextureInfo& info,
+                             ID3D11ShaderResourceView* shaderResourceView,
+                             ID3D11RenderTargetView* renderTargetView,
+                             GrMipmapStatus,
+                             std::string_view label);
+
+    // non-MSAA, wrapped
+    GrD3D11TextureRenderTarget(GrD3D11Gpu* gpu,
+                             SkISize dimensions,
+                             const GrD3D11TextureInfo& info,
+                             ID3D11ShaderResourceView* shaderResourceView,
+                             ID3D11RenderTargetView* renderTargetView,
+                             GrMipmapStatus,
+                             GrWrapCacheable,
+                             std::string_view label);
+
+    // GrGLRenderTarget accounts for the texture's memory and any MSAA renderbuffer's memory.
+    size_t onGpuMemorySize() const override;
+
+    void onSetLabel() override;
+};
+
+#ifdef SK_BUILD_FOR_WIN
+#pragma warning(pop)
+#endif
diff --git a/src/gpu/ganesh/d3d11/GrD3D11Types.cpp b/src/gpu/ganesh/d3d11/GrD3D11Types.cpp
new file mode 100644
index 0000000000..275619076d
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11Types.cpp
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2019 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/gpu/ganesh/d3d11/GrD3D11Types.h"
+
+#include "include/gpu/ganesh/GrBackendSurface.h"
+#include "include/private/gpu/ganesh/GrD3D11TypesPriv.h"
+
+GrBackendFormat GrD3D11TextureInfo::getBackendFormat() const {
+    return GrBackendFormat::MakeDxgi(fFormat);
+}
+
+GrD3D11TextureInfo GrD3D11TextureInfo::getInfo(const GrBackendTexture& backend) {
+    GrD3DTextureResourceInfo d3d12Info;
+    backend.getD3DTextureResourceInfo(&d3d12Info);
+    return GrD3D11TextureInfo(d3d12Info);
+}
+
+GrD3D11TextureInfo GrD3D11TextureInfo::getInfo(const GrBackendRenderTarget& backend) {
+    GrD3DTextureResourceInfo d3d12Info;
+    backend.getD3DTextureResourceInfo(&d3d12Info);
+    return GrD3D11TextureInfo(d3d12Info);
+}
diff --git a/src/gpu/ganesh/d3d11/GrD3D11UniformDataManager.cpp b/src/gpu/ganesh/d3d11/GrD3D11UniformDataManager.cpp
new file mode 100644
index 0000000000..574b9300a2
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11UniformDataManager.cpp
@@ -0,0 +1,50 @@
+/*
+* Copyright 2016 Google Inc.
+*
+* Use of this source code is governed by a BSD-style license that can be
+* found in the LICENSE file.
+*/
+
+#include "src/gpu/ganesh/d3d11/GrD3D11UniformDataManager.h"
+
+#include "src/gpu/ganesh/d3d11/GrD3D11Gpu.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Buffer.h"
+
+GrD3D11UniformDataManager::GrD3D11UniformDataManager(const UniformInfoArray& uniforms,
+                                                             uint32_t uniformSize)
+    : INHERITED(uniforms.count(), uniformSize) {
+    // We must add uniforms in same order as the UniformInfoArray so that UniformHandles already
+    // owned by other objects will still match up here.
+    int i = 0;
+    for (const auto& uniformInfo : uniforms.items()) {
+        Uniform& uniform = fUniforms[i];
+        SkASSERT(GrShaderVar::kNonArray == uniformInfo.fVariable.getArrayCount() ||
+                 uniformInfo.fVariable.getArrayCount() > 0);
+        SkDEBUGCODE(
+            uniform.fArrayCount = uniformInfo.fVariable.getArrayCount();
+            uniform.fType = uniformInfo.fVariable.getType();
+        )
+
+        uniform.fOffset = uniformInfo.fUBOOffset;
+        ++i;
+    }
+}
+
+void GrD3D11UniformDataManager::uploadConstants(GrD3D11Gpu* gpu) 
+{
+    if (fUniformSize > 0) {
+        if (!fUniformBuffer) {
+            fUniformBuffer = GrD3D11Buffer::Make(
+                    gpu, fUniformSize, GrGpuBufferType::kUniform, kDynamic_GrAccessPattern);
+        }
+
+        if (fUniformsDirty) {
+            fUniformBuffer->updateData(fUniformData.get(), 0, fUniformSize, false);
+            fUniformsDirty = false;
+        }
+
+        auto buf = fUniformBuffer->d3d11Resource();
+        gpu->deviceContext()->VSSetConstantBuffers(0, 1, &buf);
+        gpu->deviceContext()->PSSetConstantBuffers(0, 1, &buf);
+    }
+}
diff --git a/src/gpu/ganesh/d3d11/GrD3D11UniformDataManager.h b/src/gpu/ganesh/d3d11/GrD3D11UniformDataManager.h
new file mode 100644
index 0000000000..bf0bcdd538
--- /dev/null
+++ b/src/gpu/ganesh/d3d11/GrD3D11UniformDataManager.h
@@ -0,0 +1,34 @@
+/*
+* Copyright 2020 Google LLC
+*
+* Use of this source code is governed by a BSD-style license that can be
+* found in the LICENSE file.
+*/
+
+#ifndef GrD3D11UniformDataManager_DEFINED
+#define GrD3D11UniformDataManager_DEFINED
+
+#include "src/gpu/ganesh/GrUniformDataManager.h"
+
+#include "include/gpu/ganesh/d3d11/GrD3D11Types.h"
+#include "src/gpu/ganesh/GrSPIRVUniformHandler.h"
+#include "src/gpu/ganesh/d3d11/GrD3D11Buffer.h"
+
+class GrD3D11Gpu;
+class GrD3D11Buffer;
+
+class GrD3D11UniformDataManager : public GrUniformDataManager {
+public:
+    typedef GrSPIRVUniformHandler::UniformInfoArray UniformInfoArray;
+
+    GrD3D11UniformDataManager(const UniformInfoArray&,
+                                  uint32_t uniformSize);
+
+    void uploadConstants(GrD3D11Gpu* gpu);
+
+private:
+    sk_sp<GrD3D11Buffer> fUniformBuffer;
+    using INHERITED = GrUniformDataManager;
+};
+
+#endif
diff --git a/src/gpu/ganesh/glsl/GrGLSLShaderBuilder.h b/src/gpu/ganesh/glsl/GrGLSLShaderBuilder.h
index 63766f2887..39df0c6f50 100644
--- a/src/gpu/ganesh/glsl/GrGLSLShaderBuilder.h
+++ b/src/gpu/ganesh/glsl/GrGLSLShaderBuilder.h
@@ -286,6 +286,7 @@ protected:
     friend class GrGLSLProgramBuilder;
     friend class GrGLProgramBuilder;
     friend class GrD3DPipelineStateBuilder;
+    friend class GrD3D11ProgramBuilder;
     friend class GrDawnProgramBuilder;
     friend class GrGLSLVaryingHandler; // to access noperspective interpolation feature.
     friend class GrGLPathProgramBuilder; // to access fInputs.
diff --git a/src/sksl/codegen/SkSLSPIRVtoHLSL.cpp b/src/sksl/codegen/SkSLSPIRVtoHLSL.cpp
index 0f48438fcb..0e72fbdddb 100644
--- a/src/sksl/codegen/SkSLSPIRVtoHLSL.cpp
+++ b/src/sksl/codegen/SkSLSPIRVtoHLSL.cpp
@@ -14,7 +14,7 @@
  * Each library is built with a separate copy of spirv.h (or spirv.hpp), so we
  * avoid conflicts by never including both in the same cpp.
  */
-
+int shader_model = 51;
 namespace SkSL {
 
 void SPIRVtoHLSL(const std::string& spirv, std::string* hlsl) {
@@ -27,7 +27,7 @@ void SPIRVtoHLSL(const std::string& spirv, std::string* hlsl) {
     optionsGLSL.force_zero_initialized_variables = true;
 
     spirv_cross::CompilerHLSL::Options optionsHLSL;
-    optionsHLSL.shader_model = 51;
+    optionsHLSL.shader_model = shader_model;
     // PointCoord and PointSize are not supported in HLSL
     optionsHLSL.point_coord_compat = true;
     optionsHLSL.point_size_compat = true;
diff --git a/tools/viewer/Viewer.cpp b/tools/viewer/Viewer.cpp
index aa54f9282a..5d27f34078 100644
--- a/tools/viewer/Viewer.cpp
+++ b/tools/viewer/Viewer.cpp
@@ -1365,6 +1365,7 @@ void Viewer::setCurrentSlide(int slide) {
                          SkIntToScalar(fWindow->height()) / scaleFactor);
     fCurrentSlide = slide;
     this->setupCurrentSlide();
+    SkDebugf("current slide %s %d\n", fSlides[slide]->getName().c_str(), slide);
 }
 
 SkISize Viewer::currentSlideSize() const {
diff --git a/tools/window/win/D3D12WindowContext_win.cpp b/tools/window/win/D3D12WindowContext_win.cpp
index 54512df9e6..0a63735ef5 100644
--- a/tools/window/win/D3D12WindowContext_win.cpp
+++ b/tools/window/win/D3D12WindowContext_win.cpp
@@ -20,6 +20,8 @@
 #include <dxgi1_4.h>
 #include <wrl/client.h>
 
+#include <d3d11.h>
+
 #define GR_D3D_CALL_ERRCHECK(X)                                         \
     do {                                                                \
         HRESULT result = X;                                             \
@@ -252,12 +254,196 @@ void D3D12WindowContext::setDisplayParams(const DisplayParams& params) {
     this->initializeContext();
 }
 
+class D3D11WindowContext : public WindowContext {
+public:
+    D3D11WindowContext(HWND hwnd, const DisplayParams& params);
+    ~D3D11WindowContext() override;
+    void initializeContext();
+    void destroyContext();
+    void setupSurfaces(int width, int height);
+
+    bool isValid() override { return fDevice.get() != nullptr; }
+
+    sk_sp<SkSurface> getBackbufferSurface() override;
+    void onSwapBuffers() override;
+
+    void resize(int width, int height) override;
+    void setDisplayParams(const DisplayParams& params) override;
+
+private:
+    HWND fWindow;
+    gr_cp<ID3D11Device> fDevice;
+    gr_cp<ID3D11DeviceContext> fDeviceContext;
+    gr_cp<IDXGISwapChain> fSwapChain;
+    gr_cp<ID3D11Texture2D> fBackBuffer;
+
+    sk_sp<SkSurface> fSurface;
+};
+
+D3D11WindowContext::D3D11WindowContext(HWND hwnd, const DisplayParams& params)
+        : WindowContext(params), fWindow(hwnd) {
+    this->initializeContext();
+}
+
+#include <dxgidebug.h>
+D3D11WindowContext::~D3D11WindowContext() {
+    this->destroyContext();
+#ifdef SK_DEBUG
+    IDXGIDebug* debugDev;
+    HRESULT hr = DXGIGetDebugInterface1(0, IID_PPV_ARGS(&debugDev));
+    GR_D3D_CALL_ERRCHECK(hr);
+
+    debugDev->ReportLiveObjects(DXGI_DEBUG_ALL, DXGI_DEBUG_RLO_ALL);
+    debugDev->Release();
+#endif
+}
+
+void D3D11WindowContext::initializeContext() {
+#if 0
+    while (!IsDebuggerPresent())
+    {
+        Sleep(30);
+    }
+#endif
+
+    UINT createDeviceFlags = D3D11_CREATE_DEVICE_SINGLETHREADED | D3D11_CREATE_DEVICE_BGRA_SUPPORT;
+#ifdef SK_DEBUG
+    createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;
+#endif
+    D3D_FEATURE_LEVEL featureLevel;
+
+    HRESULT hres = D3D11CreateDevice(NULL,
+                                     D3D_DRIVER_TYPE_HARDWARE,
+                                     NULL,
+                                     createDeviceFlags,
+                                     NULL,
+                                     0,
+                                     D3D11_SDK_VERSION,
+                                     &fDevice,
+                                     &featureLevel,
+                                     &fDeviceContext);
+    GR_D3D_CALL_ERRCHECK(hres);
+
+    GrD3DBackendContext backendContext;
+    backendContext.fD3D11Device = fDevice.get();
+    backendContext.fD3D11DeviceContext = fDeviceContext.get();
+    SkASSERT(backendContext.fD3D11Device && backendContext.fD3D11DeviceContext);
+
+    IDXGIFactory1* DXGIFactory;
+    GR_D3D_CALL_ERRCHECK(
+            CreateDXGIFactory1(__uuidof(IDXGIFactory1), reinterpret_cast<void**>(&DXGIFactory)));
+
+    fContext = GrDirectContext::MakeDirect3D(backendContext, fDisplayParams.fGrContextOptions);
+    SkASSERT(fContext);
+
+    // Make the swapchain
+    RECT windowRect;
+    GetWindowRect(fWindow, &windowRect);
+    unsigned int width = windowRect.right - windowRect.left;
+    unsigned int height = windowRect.bottom - windowRect.top;
+
+    DXGI_SWAP_CHAIN_DESC presentationParams{};
+
+    DXGI_SAMPLE_DESC sampleDesc;
+    sampleDesc.Count = 1;
+    sampleDesc.Quality = 0;
+
+    presentationParams.BufferCount = 2;
+    presentationParams.BufferDesc.Width = width;
+    presentationParams.BufferDesc.Height = height;
+    presentationParams.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
+    presentationParams.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
+    presentationParams.OutputWindow = fWindow;
+    presentationParams.SampleDesc = sampleDesc;
+    presentationParams.Windowed = TRUE;
+    presentationParams.BufferDesc.RefreshRate.Numerator = 60;
+    presentationParams.BufferDesc.RefreshRate.Denominator = 1;
+    presentationParams.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
+
+    GR_D3D_CALL_ERRCHECK(
+            DXGIFactory->CreateSwapChain(fDevice.get(), &presentationParams, &fSwapChain));
+
+    DXGIFactory->Release();
+
+    this->setupSurfaces(width, height);
+
+    fWidth = width;
+    fHeight = height;
+}
+
+void D3D11WindowContext::setupSurfaces(int width, int height) {
+    GR_D3D_CALL_ERRCHECK(fSwapChain->GetBuffer(0, IID_PPV_ARGS(&fBackBuffer)));
+
+    D3D11_TEXTURE2D_DESC desc;
+    fBackBuffer->GetDesc(&desc);
+
+    SkASSERT(desc.Width == (UINT64)width && desc.Height == (UINT64)height);
+
+    // set up base resource info
+    GrD3DTextureResourceInfo info(
+            nullptr, nullptr, D3D12_RESOURCE_STATE_PRESENT, DXGI_FORMAT_R8G8B8A8_UNORM, 1, 1, 0);
+
+    info.fResource.retain((ID3D12Resource*)fBackBuffer.get());
+
+    GrBackendRenderTarget backendRT(width, height, info);
+    fSurface = SkSurfaces::WrapBackendRenderTarget(fContext.get(),
+                                                      backendRT,
+                                                      kTopLeft_GrSurfaceOrigin,
+                                                      kRGBA_8888_SkColorType,
+                                                      fDisplayParams.fColorSpace,
+                                                      &fDisplayParams.fSurfaceProps);
+}
+
+void D3D11WindowContext::destroyContext() {
+    fSurface.reset();
+    fDeviceContext.reset();
+    fDevice.reset();
+    fBackBuffer.reset();
+    fSwapChain.reset();
+    fContext.reset();
+}
+
+sk_sp<SkSurface> D3D11WindowContext::getBackbufferSurface() { return fSurface; }
+
+void D3D11WindowContext::onSwapBuffers() {
+    SkSurface* surface = fSurface.get();
+
+    GrFlushInfo info;
+    fContext->flush(surface, SkSurfaces::BackendSurfaceAccess::kPresent, info);
+    fContext->submit();
+
+    GR_D3D_CALL_ERRCHECK(fSwapChain->Present(1, 0));
+}
+
+void D3D11WindowContext::resize(int width, int height) {
+    // Clean up any outstanding resources in command lists
+    fContext->flush();
+    fContext->submit(GrSyncCpu::kYes);
+
+    fBackBuffer.reset();
+    fSurface.reset();
+
+    auto hr = fSwapChain->ResizeBuffers(0, width, height, DXGI_FORMAT_R8G8B8A8_UNORM, 0);
+    GR_D3D_CALL_ERRCHECK(hr);
+
+    this->setupSurfaces(width, height);
+
+    fWidth = width;
+    fHeight = height;
+}
+
+void D3D11WindowContext::setDisplayParams(const DisplayParams& params) {
+    this->destroyContext();
+    fDisplayParams = params;
+    this->initializeContext();
+}
+
 } // anonymous namespace
 
 namespace skwindow {
 
 std::unique_ptr<WindowContext> MakeD3D12ForWin(HWND hwnd, const DisplayParams& params) {
-    std::unique_ptr<WindowContext> ctx(new D3D12WindowContext(hwnd, params));
+    std::unique_ptr<WindowContext> ctx(new D3D11WindowContext(hwnd, params));
     if (!ctx->isValid()) {
         return nullptr;
     }
